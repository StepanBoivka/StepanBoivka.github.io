<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Карта земельних ділянок</title>
    
    <!-- CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-layers-tree@1.0.0/dist/leaflet-control-layers-tree.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-search@3.0.0/dist/leaflet-search.min.css">
    <link rel="stylesheet" href="css/area-tooltip.css">
    <link rel="stylesheet" href="css/leaflet.draw.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-easybutton@2.4.0/src/easy-button.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.css" />
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">

    <style>
        html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    overflow: hidden;
}

#map {
    position: absolute;
    top: 56px;
    bottom: 0;
    left: 0;
    right: 0;
    width: 100%;
    margin: 0;
    padding: 0;
}

.navbar {
    z-index: 1000;
    height: 56px; /* Фіксована висота навбару */
}

/* Зберігаємо всі стилі з оригінальної версії */
.color-box {
    width: 12px;
    height: 12px;
    display: inline-block;
    margin-right: 5px;
}

.layer-name {
    color: black;
    font-size: 12px;
}

.leaflet-control-search {
    top: 5px !important;
}

/* Адаптивність для смартфонів */
@media (max-width: 576px) {
    #fileSelect {
        max-width: calc(100% - 100px);
        font-size: 14px;
    }
    
    .navbar {
        padding: 0.3rem;
    }
}
.select-custom {
    width: 200px; /* Зменшуємо стандартну ширину */
}

.select-custom-small {
    width: 80px; /* Зменшуємо стандартну ширину */
}

/* Стилі для відкритого списку */
.select-custom option, 
.select-custom-small option {
    width: auto;
    min-width: 200px; /* Мінімальна ширина для відкритого списку */
    white-space: normal; /* Дозволяємо перенос тексту */
}

/* Адаптивність для різних екранів */
@media (max-width: 992px) {
    .select-custom {
        width: 150px;
    }
    .select-custom-small {
        width: 70px;
    }
}

@media (max-width: 576px) {
    .select-custom {
        width: 120px;
        font-size: 12px; /* Зменшуємо розмір шрифту */
    }
    .select-custom-small {
        width: 60px;
        font-size: 12px;
    }
}

@media (max-width: 400px) {
    .select-custom {
        width: 100px;
    }
    .select-custom-small {
        width: 50px;
    }
    /* Зменшуємо відступ між селектами */
    .ms-2 {
        margin-left: 0.3rem !important;
    }
}

/* Додаємо еліпсис для довгого тексту */
.select-custom, .select-custom-small {
    text-overflow: ellipsis;
    overflow: hidden;
}

/* Стиль для тексту в закритому селекті */
.select-custom option, .select-custom-small option {
    text-overflow: ellipsis;
}

/* Оновлені стилі для спливаючого вікна */
.popup-content {
    padding: 8px;
    font-size: 11px;
    max-height: 300px;
    overflow: auto;
}

.popup-content table {
    width: 100%;
    border-collapse: separate;
    border-spacing: 0 3px;
}

.popup-content td {
    padding: 1px 0;
    vertical-align: top;
    line-height: 1.2;
}

.popup-content td.property-name {
    font-weight: bold;
    padding-right: 8px;
    white-space: nowrap;
}

.popup-content td.property-value {
    padding-left: 4px;
}

/* Видаліть старі стилі для вкладок */
.popup-tabs,
.popup-tab {
    display: none;
}

.modal {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
}

.modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px солід #888;
    width: 80%;
    max-width: 500px;
    border-radius: 5px;
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

#cadastralList {
    width: 100%;
    height: 150px;
    margin: 10px 0;
    padding: 5px;
}
@keyframes pulse {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.8;
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}

.custom-div-icon {
    margin-left: -10px !important;
    margin-top: -10px !important;
}
.nav-tabs .nav-link {
    color: #495057;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    margin-right: 5px;
}

.nav-tabs .nav-link.active {
    color: #495057;
    background-color: #fff;
    border-color: #dee2e6 #dee2e6 #fff;
}

.tab-content {
    padding: 15px;
    border: 1px солід #dee2e6;
    border-top: none;
    border-radius: 0 0 4px 4px;
}

.select-custom-small {
    width: 100px; /* Стандартна ширина для десктопів */
}

@media (max-width: 992px) {
    .select-custom-small {
        width: 80px; /* Для планшетів */
    }
}

@media (max-width: 576px) {
    .select-custom-small {
        width: 70px; /* Для мобільних */
    }
}

@media (max-width: 400px) {
    .select-custom-small {
        width: 60px; /* Для дуже малих екранів */
    }
}

.popup-link {
    text-align: center;
    margin-top: 5px;
    padding-top: 5px;
    border-top: 1px солід #eee;
}

.popup-link a {
    display: inline-block;
    color: #198754; /* Bootstrap зелений колір */
    text-decoration: none;
}

.popup-link i {
    font-size: 18px;
}

.popup-link a:hover {
    color: #157347; /* Темніший зелений при наведенні */
}

.popup-link .text-end {
    font-size: 0.9em;
    color: #666;
}
    .data-freshness-indicator {
        font-size: 0.8rem;
    }
    .data-freshness-indicator i {
        font-size: 1rem;
    }
    .freshness-good {
        color: #28a745 !important;
    }
    .freshness-warning {
        color: #ffc107 !important;
    }
    @keyframes blink {
        0% { opacity: 1; }
        50% { opacity: 0.3; }
        100% { opacity: 1; }
    }

    .freshness-бад {
        color: #dc3545 !important;
        animation: blink 2s ease-in-out infinite;
    }
    /* Стили для выделенных участков */
    .selected-polygon {
        filter: brightness(1.3);
    }

    .selected-polygon path {
        stroke: #FFFF00 !important;
        stroke-width: 3 !important;
        stroke-dasharray: 10, 10 !important;
        animation: dash 20s linear infinite;
    }

    @keyframes dash {
        0% {
            stroke-dashoffset: 0;
        }
        100% {
            stroke-dashoffset: -1000;
        }
    }
    /* Стили для инструментов измерения */
    .leaflet-draw-tooltip {
        background: rgb(54, 54, 54);
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid transparent;
        border-radius: 4px;
        color: #fff;
        font: 12px/18px "Helvetica Neue", Arial, Helvetica, sans-serif;
        margin-left: 20px;
        margin-top: -21px;
        padding: 4px 8px;
        position: absolute;
        visibility: hidden;
        white-space: nowrap;
        z-index: 6;
    }
    /* Додати нові стилі */
.offcanvas {
    --bs-offcanvas-width: 300px;
}

@media (max-width: 576px) {
    .offcanvas {
        --bs-offcanvas-width: 260px;
    }
}

.offcanvas-title {
    font-size: 1.1rem;
}

.form-label {
    font-size: 0.9rem;
    margin-bottom: 0.3rem;
}

/* Оновлені стилі для селектів */
.offcanvas .form-select {
    width: 100%;
    max-width: 100%;
}

/* Стиль для кнопки відкриття меню */
.navbar .btn-outline-light:hover {
    background-color: rgba(255,255,255,0.1);
}

/* Покращення читабельності тексту в темній темі */
.offcanvas.bg-dark {
    --bs-bg-opacity: 0.95;
}

.offcanvas .form-select option {
    background-color: var(--bs-dark);
    color: var(--bs-light);
}
    /* Оновлений CSS для текстових полів у модальному вікні */
.modal textarea {
    width: 100%;
    min-height: 120px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
}

.modal textarea:focus {
    border-color: #80bdff;
    outline: 0;
    box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
}

.modal .tab-content {
    padding: 15px;
    background: #fff;
}
.tools-menu {
    background-color: white;
}

.tools-container {
    position: absolute;
    right: 35px;
    top: 0;
    background-color: white;
    padding: 5px;
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    z-index: 1000;
    width: auto;
    white-space: nowrap;
}

.tools-group-title {
    font-weight: bold;
    margin-top: 5px;
    margin-bottom: 5px;
}

.tools-group {
    margin-bottom: 10px;
}

.tool-button {
    display: block;
    margin: 5px 0;
    width: 30px;
    height: 30px;
    line-height: 30px;
    text-align: center;
    background-color: white;
    color: #666;
    border-radius: 4px;
}

.tool-title {
    margin-left: 5px;
    font-size: 14px;
    vertical-align: middle;
}
    #exchangeTable {
        width: 100%;
        margin-bottom: 1rem;
        font-size: 14px;
    }

    #exchangeTable th,
    #exchangeTable td {
        padding: 8px;
        vertical-align: top;
    }

    #exchangeModal .modal-content {
        width: 90%;
        max-width: 800px;
    }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js"></script>
</head>
<body>
    <!-- Оставляем тільки один navbar -->
    <nav class="navbar navbar-dark bg-dark fixed-top py-1">
        <div class="container-fluid px-2">
            <!-- Кнопка для відкриття бокового меню -->
            <button class="btn btn-outline-light btn-sm" 
                    type="button" 
                    data-bs-toggle="offcanvas" 
                    data-bs-target="#mainMenu"
                    aria-controls="mainMenu"
                    style="width: 32px; height: 32px;">
                <i class="bi bi-list"></i>
            </button>

            <!-- Індикатор актуальності даних -->
            <div class="data-freshness-indicator d-flex align-items-center ms-2">
                <i class="bi bi-clock-history text-light me-1"></i>
                <small class="text-light" id="dataFreshnessText"></small>
            </div>
        </div>
    </nav>

    <!-- Бокове меню -->
    <div class="offcanvas offcanvas-start bg-dark text-light" tabindex="-1" id="mainMenu">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">Головне меню</h5>
            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Секція вибору області перегляду -->
            <div class="mb-4">
                <h6 class="border-bottom border-secondary pb-2 mb-3">Вибір області перегляду</h6>
                <div class="mb-3">
                    <label for="fileSelect" class="form-label">Рада</label>
                    <select class="form-select form-select-sm bg-dark text-light border-secondary" id="fileSelect">
                        <option>Виберіть раду</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="fieldSelect" class="form-label">Поле обробітку</label>
                    <select class="form-select form-select-sm bg-dark text-light border-secondary" id="fieldSelect">
                        <option value="">Всі поля</option>
                    </select>
                </div>
                <!-- Додаємо новий select для фільтрації за роком -->
                <div class="mb-3">
                    <label for="expiryYearSelect" class="form-label">Завершення оренди</label>
                    <select class="form-select form-select-sm bg-dark text-light border-secondary" id="expiryYearSelect">
                        <option value="">Всі роки</option>
                    </select>
                </div>
            </div>
            <!-- Секція інструментів -->
            <div class="mb-4">
                <h6 class="border-bottom border-secondary pb-2 mb-3">Інструменти</h6>
                <div class="d-grid gap-2">
                    <button class="btn btn-outline-light text-start" id="cadastralSearchButton">
                        <i class="bi bi-search me-2"></i>
                        Пошук за списком номерів
                    </button>
                    <button class="btn btn-outline-light text-start" id="statisticsButton">
                        <i class="bi bi-pie-chart-fill me-2"></i>
                        Статистика
                    </button>
                    <button class="btn btn-outline-light text-start" id="exportButton">
                        <i class="bi bi-table me-2"></i>
                        Експорт в Excel
                    </button>
                    <button class="btn btn-outline-light text-start" id="freshnessButton">
                        <i class="bi bi-database me-2"></i>
                        Мої ресурси
                    </button>
                    <button class="btn btn-outline-light text-start" id="exchangeButton">
                        <i class="bi bi-arrow-left-right me-2"></i>
                        Пропозиція обміну
                    </button>
                    <div id="selectionTools" style="display: none;">
                        <button class="btn btn-outline-warning text-start w-100 mb-2" data-action="clear-selection">
                            <i class="bi bi-trash3 me-2"></i>
                            Очистити виділення
                        </button>
                        <button class="btn btn-outline-success text-start w-100" data-action="export-selected">
                            <i class="bi bi-file-earmark-excel me-2"></i>
                            Експортувати виділені
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Карта -->
    <div id="map"></div>
    <!-- Modal for cadastral numbers input -->
<div id="cadastralModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h5>Пошук за кадастровими номерами</h5>
        <ul class="nav nav-tabs" id="cadastralTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="own-tab" data-bs-toggle="tab" data-bs-target="#own" type="button">
                    Свої ділянки
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="others-tab" data-bs-toggle="tab" data-bs-target="#others" type="button">
                    Чужі ділянки
                </button>
            </li>
        </ul>
        <div class="tab-content" id="cadastralTabContent">
            <div class="tab-pane fade show active" id="own" role="tabpanel">
                <p class="text-muted mb-2">Вставте список своїх кадастрових номерів (кожен з нового рядка)</p>
                <textarea id="ownCadastralList" 
                          class="form-control" 
                          placeholder="Наприклад:&#10;6821555100:05:006:0001&#10;6821555100:05:006:0002"></textarea>
            </div>
            <div class="tab-pane fade" id="others" role="tabpanel">
                <p class="text-muted mb-2">Вставте список чужих кадастрових номерів (кожен з нового рядка)</p>
                <textarea id="othersCadastralList" 
                          class="form-control" 
                          placeholder="Наприклад:&#10;6821555100:05:006:0003&#10;6821555100:05:006:0004"></textarea>
            </div>
        </div>
        <div class="mt-3">
            <button type="button" class="btn btn-primary" id="searchCadastral">Пошук</button>
            <button type="button" class="btn btn-secondary ms-2" onclick="clearCadastralLists()">Очистити</button>
        </div>
    </div>
</div>

<!-- Modal for GeoJSON export -->
<div id="exportModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h5>Експорт даних</h5>
        <div class="mb-3">
            <label for="exportFilename" class="form-label">Назва файлу</label>
            <input type="text" class="form-control" id="exportFilename" placeholder="Введіть назву файлу...">
        </div>
        <div class="mb-3">
            <label class="form-label">Формат файлу</label>
            <select class="form-select" id="exportFormat">
                <option value="geojson">GeoJSON</option>
                <option value="kml">KML</option>
            </select>
        </div>
        <div class="mb-3">
            <label class="form-label">Полігони</label>
            <div id="polygonsList" class="list-group mb-2">
                <!-- Тут будуть полігони -->
            </div>
        </div>
        <button class="btn btn-primary" id="confirmExport">Експортувати</button>
    </div>
</div>

<!-- Знайдіть div з id="exportModal" і додайте після нього новий модал -->
<div id="loadModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h5>Завантаження полігонів</h5>
        <div class="mb-3">
            <label for="fileInput" class="form-label">Виберіть GeoJSON або KML файл</label>
            <input type="file" class="form-control" id="fileInput" accept=".geojson,.kml">
        </div>
        <div class="mb-3">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="clearExisting">
                <label class="form-check-label" for="clearExisting">
                    Очистити існуючі полігони перед завантаженням
                </label>
            </div>
        </div>
        <button class="btn btn-primary" id="confirmLoad">Завантажити</button>
    </div>
</div>

<!-- Modal for exchange proposal -->
<div id="exchangeModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h5>Пропозиція обміну земельними ділянками</h5>
        <div class="mb-3">
            <label for="exchangeList" class="form-label">Введіть кадастрові номери для обміну</label>
            <textarea id="exchangeList" class="form-control" rows="5" 
                     placeholder="Введіть кадастрові номери, кожен з нового рядка"></textarea>
        </div>
        <div class="mb-3">
            <button type="button" class="btn btn-primary" id="generateExchange">Сформувати</button>
        </div>
        <div id="exchangeTableContainer" style="display: none;">
            <div id="exchangeSummary" class="mb-3">
                <!-- Здесь будет краткая сводка по обмену -->
            </div>
            <div id="fieldTables" style="display: none;">
                <!-- Сюда будут добавляться таблицы -->
            </div>
            <div id="exchangeAnalysisContainer" class="mt-4">
                <h6>АНАЛІЗ РІВНОЦІННОСТІ ОБМІНУ:</h6>
                <div id="exchangeAnalysis"></div>
            </div>
            <div class="mt-3 d-flex justify-content-between align-items-center">
                <div><strong>Загальна площа обміну: </strong><span id="totalArea">0</span> га</div>
                <button type="button" class="btn btn-success" id="exportPDF">
                    <i class="bi bi-file-pdf me-2"></i>Експорт в PDF
                </button>
            </div>
        </div>
    </div>
</div>

    <!-- Скрипты -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-control-layers-tree@1.0.0/dist/leaflet-control-layers-tree.js"></script>
    <script src="https://unpkg.com/leaflet-search@3.0.0/dist/leaflet-search.min.js"></script>
    <script src="https://unpkg.com/leaflet-geometryutil/src/leaflet.geometryutil.js"></script>
    <script src="js/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-easybutton@2.4.0/src/easy-button.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet.locatecontrol/dist/L.Control.Locate.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/leaflet-control-layers-tree@1.0.0/dist/leaflet-control-layers-tree.js"></script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CMBXL0TQLR"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-CMBXL0TQLR');
    </script>
    <!-- Основной скрипт -->
    <script>
        // Глобальные переменные
        let selectedFeatures = new Set();
        let isCtrlPressed = false;
        let map, layersControl, searchControl, fieldLayer;
        let overlays = {};
        let tenantColors = {};
        let tenantAreas = {};
        let freeLayer;
        let freeArea = 0;
        let originalGeoJsonData;
        let baseMaps = {};
        let cadastralModal;
        let ownMarkersLayer, othersMarkersLayer;
        let editableLayers;

        // Функция для сбора данных карты с видимых слоев
        function collectMapData() {
            // Используем сет для предотвращения дублирования
            const uniqueProperties = new Set();
            const data = [];
            
            // Собираем все видимые слои типа split
            Object.values(overlays).forEach(layerGroup => {
                // Проверяем что это слой
                if (!layerGroup || typeof layerGroup.eachLayer !== 'function') return;
                
                // Проверяем видим ли слой
                if (map.hasLayer(layerGroup)) {
                    
                    layerGroup.eachLayer(layer => {
                        if (layer.feature && layer.feature.properties) {
                            // Проверяем тип объекта
                            if (layer.feature.properties.type === 'split') {
                                // Создаем уникальный идентификатор для свойств
                                const kadNum = layer.feature.properties["Кадастровий номер"];
                                const tenant = layer.feature.properties["Орендар частини"] || 
                                            layer.feature.properties["Орендар"] || "";
                                const status = layer.feature.properties["Статус"] || "";
                                
                                const propId = `${kadNum}_${tenant}_${status}`;
                                
                                // Проверяем, не добавляли ли мы уже этот объект
                                if (!uniqueProperties.has(propId)) {
                                    uniqueProperties.add(propId);
                                    data.push(layer.feature.properties);
                                }
                            }
                        }
                    });
                }
            });
            
            return data;
        }

        // Получение параметров из URL
        const urlParams = new URLSearchParams(window.location.search);
        const id = urlParams.get('id');
        const dataPath = id ? `data/${id}/` : 'data/';
        // Ждем полной загрузки страницы и всех скриптов
        document.addEventListener('DOMContentLoaded', function() {
            // Додати обробники клавіш тут, на верхньому рівні
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Control') {
                    isCtrlPressed = true;
                }
            });
            
            document.addEventListener('keyup', function(e) {
                if (e.key === 'Control') {
                    isCtrlPressed = false;
                }
            });

            initializeMap();
            // Инициализация модального окна и обработчиков событий
            cadastralModal = document.getElementById("cadastralModal");
            const closeBtn = document.getElementsByClassName("close")[0];
            // Обработчики для кнопок выпадающего меню
            document.getElementById('cadastralSearchButton').addEventListener('click', function() {
                // Закриваємо бокову панель
                var offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('mainMenu'));
                offcanvas.hide();
                // Після невеликої затримки показуємо модальне вікно
                setTimeout(() => {
                    clearCadastralLists();
                    cadastralModal.style.display = "block";
                }, 300); // Затримка для завершення анімації закриття бокової панелі
            });
                
            document.getElementById('statisticsButton').addEventListener('click', function() {
                var selectedFile = document.getElementById('fileSelect').value;
                if (selectedFile && selectedFile !== 'Виберіть раду') {
                    const urlParams = new URLSearchParams(window.location.search);
                    const id = urlParams.get('id');
                    const statisticsUrl = `statistics.html?file=${encodeURIComponent(selectedFile)}${id ? `&id=${id}` : ''}`;
                    window.location.href = statisticsUrl;
                } else {
                    alert('Будь ласка, спочатку виберіть файл з даними.');
                }
            });
            // Обработчики для модального окна
            closeBtn.onclick = function() {
                cadastralModal.style.display = "none";
                clearCadastralLists();
            }
            window.onclick = function(event) {
                if (event.target == cadastralModal) {
                    cadastralModal.style.display = "none";
                    clearCadastralLists();
                }
            }

            // Обработчик поиска кадастровых номеров
            document.getElementById('searchCadastral').addEventListener('click', searchCadastralNumbers);
            // Удаляем обработчики для навбар поиска
            // document.getElementById('navbarCadastralSearchButton').addEventListener('click', function() {
            //     searchNavbarCadastralNumber();
            // });
            // Обработчик поиска кадастровых номеров
            // document.getElementById('navbarCombinedSearchButton')
            //     .addEventListener('click', function() {
            //         searchNavbarCombined();
            //     });

            // Добавляем восстановление выбора рады
            const urlParams = new URLSearchParams(window.location.search);
            const returnFile = urlParams.get('return_file');
            if (returnFile) {
                // Дожидаемся загрузки списка файлов и выбираем нужный
                const checkSelect = setInterval(() => {
                    const select = document.getElementById('fileSelect');
                    const option = Array.from(select.options).find(opt => opt.value === returnFile);
                    if (option) {
                        clearInterval(checkSelect);
                        select.value = returnFile;
                        select.dispatchEvent(new Event('change'));
                    }
                }, 100);
            }       

            // Добавляем сохранение выбора для перехода на freshness
            document.getElementById('freshnessButton').addEventListener('click', function() {
                const urlParams = new URLSearchParams(window.location.search);
                const id = urlParams.get('id');
                const selectedFile = document.getElementById('fileSelect').value;
                
                let freshnessUrl = `freshness.html`;
                if (id) freshnessUrl += `?id=${id}`;
                if (selectedFile && selectedFile !== 'Виберіть раду') {
                    freshnessUrl += id ? '&' : '?';
                    freshnessUrl += `file=${encodeURIComponent(selectedFile)}`;
                }
                window.location.href = freshnessUrl;
            });

            function searchCadastralNumbers() {
                var ownCadastralText = document.getElementById("ownCadastralList").value;
                var othersCadastralText = document.getElementById("othersCadastralList").value;
                
                if (!ownCadastralText && !othersCadastralText) {
                    alert('Будь ласка, введіть хоча б один кадастровий номер');
                    return;
                }

                var ownNumbers = ownCadastralText.split('\n')
                    .map(num => num.trim())
                    .filter(num => num.length > 0);
                var othersNumbers = othersCadastralText.split('\n')
                    .map(num => num.trim())
                    .filter(num => num.length > 0);

                // Очищаємо попередні маркери
                ownMarkersLayer.clearLayers();
                othersMarkersLayer.clearLayers();
                
                var foundFeatures = new Map();
                
                Object.values(overlays).forEach(layerGroup => {
                    if (layerGroup && typeof layerGroup.eachLayer === 'function') {
                        layerGroup.eachLayer(layer => {
                            if (layer.feature && layer.feature.properties) {
                                var kadNum = layer.feature.properties['Кадастровий номер'];
                                
                                if (kadNum && !foundFeatures.has(kadNum)) {
                                    var isOwn = ownNumbers.includes(kadNum);
                                    var isOther = othersNumbers.includes(kadNum);
                                    if (isOwn || isOther) {
                                        foundFeatures.set(kadNum, layer);
                                        var center = getPolygonCenter(layer);
                                        var marker = createMarker(center, kadNum, isOwn);
                                        marker.bindPopup(`
                                            <div style="font-size: 14px; font-weight: bold;">
                                                ${kadNum}
                                                <br>
                                                <span style="color: ${isOwn ? '#28a745' : '#dc3545'}">
                                                    ${isOwn ? 'Своя ділянка' : 'Чужа ділянка'}
                                                </span>
                                            </div>
                                        `, {
                                            offset: [0, -20]
                                        });
                                        
                                        marker.addTo(isOwn ? ownMarkersLayer : othersMarkersLayer);
                                    }
                                }
                            }
                        });
                    }                     
                });

                if (foundFeatures.size > 0) {
                    // Создаем массив всех найденных полигонов
                    const foundLayers = Array.from(foundFeatures.values());
                    const bounds = getBoundsFromLayers(foundLayers);
                    
                    if (bounds) {
                        map.fitBounds(bounds, {
                            padding: [50, 50]
                        });
                    }
                    
                    alert(`Знайдено ${foundFeatures.size} ділянок`);
                    cadastralModal.style.display = "none";
                } else {
                    alert('Ділянок не знайдено');
                }     
            }
        });

        function initializeMap() {
    // Создаем карту один раз
    map = L.map('map', {
        zoomControl: false
    }).setView([48.3794, 31.1656], 6);
    
    // Сброс переменной
    isCtrlPressed = false;

    // Создаем базовые слои
    const googleLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
        maxZoom: 20,
        attribution: '&copy; <a href="https://www.google.com/maps">Google</a>'
    }).addTo(map);

    const openStreetMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });

    const rasterLayer = L.tileLayer(dataPath + 'tiles/sat/{z}/{x}/{y}.png', {
        maxZoom: 20,
        attribution: 'Актуальні растри'
    });

    // Инициализируем базовые слои глобально
    baseMaps = {
        "Google Maps": googleLayer,
        "OpenStreetMap": openStreetMapLayer,
        "Актуальні растри": rasterLayer
    };

    // Добавляем контроль локации
    L.control.locate({
        position: 'bottomright',
        strings: {
            title: "Показати моє місцезнаходження"
        },
        locateOptions: {
            enableHighAccuracy: true,
            maxZoom: 20,
            timeout: 10000,
            maximumAge: 0,
            watch: true
        },
    }).addTo(map);

    freeLayer = L.layerGroup();

    // Обработчик клика по карте
    map.on('click', function(e) {
        if (!isCtrlPressed && !e.originalEvent.target.closest('.leaflet-control-layers')) {
            clearSelection();
        }
    });

    // Добавляем контроль слоев
    layersControl = L.control.layers(baseMaps, overlays, {
        collapsed: true
    }).addTo(map);

    // Загружаем список файлов и поля
    loadFileList();
    addFieldLayer();

    // Инициализируем слои для маркеров после создания карты
    ownMarkersLayer = L.layerGroup().addTo(map);
    othersMarkersLayer = L.layerGroup().addTo(map);

    // Инициализация инструментов измерения
    editableLayers = new L.FeatureGroup();
    map.addLayer(editableLayers);

    // Змінюємо налаштування L.Control.Draw
    var drawControl = new L.Control.Draw({
        position: 'topright',
        draw: {
            polyline: false,
            polygon: {
                allowIntersection: false,
                showArea: true,
                drawError: {
                    color: '#e1e100',
                    timeout: 1000
                },
                shapeOptions: {
                    color: '#3388ff',
                    weight: 2
                }
            },
            circle: false,
            rectangle: false,
            marker: false,
            circlemarker: false
        },
        edit: {
            featureGroup: editableLayers,
            remove: true,
            edit: {
                selectedPathOptions: {
                    maintainColor: true,
                    opacity: 0.3
                }
            }
        }
    });
    map.addControl(drawControl);

    // Додаємо обробник події створення полігону
    map.on(L.Draw.Event.CREATED, function (e) {
        var layer = e.layer;
        
        // Рахуємо площу в гектарах
        var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
        var areaInHectares = (area / 10000).toFixed(4);
        
        // Додаємо попап з площею
        layer.bindPopup('Площа: ' + areaInHectares + ' га');
        
        // Додаємо полігон до шару для редагування
        editableLayers.addLayer(layer);
    });

    // Оновлюємо попап з площею при редагуванні
    map.on(L.Draw.Event.EDITED, function (e) {
        e.layers.eachLayer(function (layer) {
            if (layer instanceof L.Polygon) {
                var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                var areaInHectares = (area / 10000).toFixed(4);
                layer.setPopupContent('Площа: ' + areaInHectares + ' га');
            }
        });
    });

    // Додаємо випадаюче меню з інструментами
var toolsButton = L.Control.extend({
    options: {
        position: 'topright'
    },
    onAdd: function (map) {
        var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control tools-menu');

        // Головна кнопка
        var mainButton = L.DomUtil.create('a', 'tools-main-button', container);
        mainButton.href = '#';
        mainButton.title = 'Інструменти редагування';
        mainButton.innerHTML = '<i class="bi bi-tools"></i>';

        // Контейнер для кнопок інструментів
        var toolsContainer = L.DomUtil.create('div', 'tools-container', container);
        toolsContainer.style.display = 'none';

        // Групуємо інструменти за категоріями
        const toolGroups = [
            {
                title: 'Малювання',
                tools: [
                    { icon: 'bi-pencil-square', title: 'Малювати полігон', action: function() { 
                        new L.Draw.Polygon(map).enable();
                    }},
                    { icon: 'bi-arrows-move', title: 'Редагувати полігони', action: function() {
                        new L.EditToolbar.Edit(map, {featureGroup: editableLayers}).enable();
                    }},
                    { icon: 'bi-trash', title: 'Видалити полігон', action: function() {
                        new L.EditToolbar.Delete(map, {featureGroup: editableLayers}).enable(); 
                    }}
                ]
            },
            {
                title: 'Операції',
                tools: [
                    { icon: 'bi-scissors', title: 'Розрізати полігон', action: function() {
                        startCutMode();
                    }},
                    { icon: 'bi-unity', title: 'Об\'єднати полігони', action: function() {
                        mergeSelectedPolygons();
                    }}
                ]
            },
            {
                title: 'Файли',
                tools: [
                    { icon: 'bi-file-earmark-arrow-down', title: 'Експорт в GeoJSON/KML', action: function() {
                        exportToGeoJSON();
                    }},
                    { icon: 'bi-folder2-open', title: 'Імпорт з GeoJSON/KML', action: function() {
                        showLoadModal();
                    }}
                ]
            }
        ];

        // Створюємо групи інструментів
        toolGroups.forEach(group => {
            if (group.title) {
                const groupTitle = L.DomUtil.create('div', 'tools-group-title', toolsContainer);
                groupTitle.textContent = group.title;
            }
            
            const groupContainer = L.DomUtil.create('div', 'tools-group', toolsContainer);
            group.tools.forEach(tool => {
                const button = L.DomUtil.create('a', 'tool-button', groupContainer);
                button.href = '#';
                button.title = tool.title;
                button.innerHTML = `<i class="bi ${tool.icon}"></i>`;
                L.DomEvent.on(button, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);
                    toolsContainer.style.display = 'none';
                    tool.action();
                });
            }); 
        });

        // Обробник кліку на головну кнопку
        L.DomEvent.on(mainButton, 'click', function(e) {
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            toolsContainer.style.display = toolsContainer.style.display === 'none' ? 'block' : 'none';
        });

        // Закриваємо меню при кліку поза ним
        L.DomEvent.on(document, 'click', function() {
            toolsContainer.style.display = 'none';
        });

        // Запобігаємо закриттю при кліку на меню
        L.DomEvent.on(container, 'click', function(e) {
            L.DomEvent.stopPropagation(e);
        });

        return container;
    }
});

// Додаємо меню на карту
map.addControl(new toolsButton());

            let cutLine = null;
            let polygonToCut = null;
            let isInCutMode = false;
            let cutPoints = [];

            function startCutMode() {
    isInCutMode = true;
    map.dragging.disable();
    map.doubleClickZoom.disable();
    // Змінюємо курсор для показу, що режим активний
    map._container.style.cursor = 'crosshair';

    // Показуємо підказку користувачу
    alert('Виберіть полігон для розрізання');

    editableLayers.eachLayer(function(layer) {
        if (layer instanceof L.Polygon) {
            // Додаємо підсвічування при наведенні
            layer.on('mouseover', function() {
                if (!polygonToCut) {
                    this.setStyle({
                        color: '#ff0000',
                        weight: 3
                    });
                }
            });

            layer.on('mouseout', function() {
                if (!polygonToCut) {
                    this.setStyle({
                        color: '#3388ff',
                        weight: 2
                    });
                }
            });

            layer.on('click', selectPolygonToCut);
        }
    });
}

function selectPolygonToCut(e) {
    if (!isInCutMode) return;

    L.DomEvent.stopPropagation(e);

    if (polygonToCut) {
        // Якщо полігон вже вибрано, ігноруємо повторний вибір
        return;
    }
    
    polygonToCut = e.target;
    
    // Підсвічуємо вибраний полігон
    polygonToCut.setStyle({
        color: '#ff0000',
        weight: 3,
        fillOpacity: 0.3
    });
    
    // Показуємо підказку для наступного кроку
    alert('Тепер клацніть по карті в двох місцях, щоб створити лінію розрізу');

    // Додаємо обробник для малювання лінії
    map.on('click', onDrawCutLine);
}
    
function onDrawCutLine(e) {
    if (!polygonToCut) return;
    
    cutPoints.push(e.latlng);

    if (cutLine) {
        map.removeLayer(cutLine);
    }

    // Показуємо лінію розрізу
    cutLine = L.polyline(cutPoints, {
        color: '#ff0000',
        weight: 3,
        dashArray: '5, 10'
    }).addTo(map);
    
    if (cutPoints.length >= 2) {
        if (performCut()) {
            cancelCutMode();
            cutButton.state('cut-inactive');
        } else {
            // Якщо розрізання не вдалося, очищаємо точки але залишаємося в режимі розрізання
            cutPoints = [];
            if (cutLine) {
                map.removeLayer(cutLine);
                cutLine = null;
            }
        }
    }
}

function cancelCutMode() {
    isInCutMode = false;
    map.dragging.enable();
    map.doubleClickZoom.enable();
    // Повертаємо стандартний курсор
    map._container.style.cursor = '';

    // Очищаємо точки розрізу
    cutPoints = [];

    // Знімаємо підсвічування з полігону
    if (polygonToCut) {
        polygonToCut.setStyle({
            color: '#3388ff',
            weight: 2,
            fillOpacity: 0.2
        });
        polygonToCut = null;
    }

    // Видаляємо всі обробники подій
    editableLayers.eachLayer(function(layer) {
        if (layer instanceof L.Polygon) {
            layer.off('mouseover');
            layer.off('mouseout');
            layer.off('click', selectPolygonToCut);
        }
    });

    map.off('click', onDrawCutLine);
}

function performCut() {
    try {
        if (!polygonToCut || cutPoints.length < 2) {
            throw new Error('Не вибрано полігон або недостатньо точок для розрізання');
        }

        const polygonGeoJSON = polygonToCut.toGeoJSON();

        // Створюємо лінію з точок кліку
        const line = turf.lineString(cutPoints.map(latlng => [latlng.lng, latlng.lat]));

        // Знаходимо перетин лінії з полігоном
        const intersection = turf.lineIntersect(line, polygonGeoJSON);
        if (intersection.features.length < 2) {
            throw new Error('Лінія розрізу повинна перетинати полігон у двох точках');
        }

        // Створюємо лінію розрізу через точки перетину
        const cutLine = turf.lineString([
            intersection.features[0].geometry.coordinates,
            intersection.features[1].geometry.coordinates
        ]);

        // Створюємо буфер навколо лінії розрізу
        const bufferedLine = turf.buffer(cutLine, 0.0001);

        // Розрізаємо полігон
        const clipped = turf.difference(polygonGeoJSON, bufferedLine);
        if (!clipped) {
            throw new Error('Помилка при розрізанні. Спробуйте інший кут розрізу.');
        }

        // Якщо отримали MultiPolygon, розділяємо його на окремі полігони
        if (clipped.geometry.type === 'MultiPolygon') {
            // Видаляємо оригінальний полігон
            editableLayers.removeLayer(polygonToCut);

            // Додаємо нові полігони
            clipped.geometry.coordinates.forEach(coords => {
                const newPolygon = turf.polygon(coords);
                // Перевіряємо чи площа нового полігону не занадто мала
                const area = turf.area(newPolygon) / 10000; // конвертуємо в га
                if (area > 0.001) { // ігноруємо дуже малі частини
                    addPolygonToMap(newPolygon, polygonToCut.feature.properties);
                }
            });
                
            return true;
        } else if (clipped.geometry.type === 'Polygon') {
            // Видаляємо оригінальний полігон
            editableLayers.removeLayer(polygonToCut);

            // Додаємо новий полігон
            addPolygonToMap(clipped, polygonToCut.feature.properties);
            return true;
        }

        throw new Error('Невдалий результат розрізання');
    } catch (error) {
        alert('Помилка при розрізанні полігону: ' + error.message);
        return false;
    }
}
        
// Додайте допоміжну функцію для додавання полігону на карту:
function addPolygonToMap(geoJSON, originalProperties) {
    const area = turf.area(geoJSON) / 10000; // конвертуємо в га
    geoJSON.properties = {
        ...originalProperties,
        "Площа розрахована": area.toFixed(4)
    };

    L.geoJSON(geoJSON, {
        style: {
            color: '#3388ff',
            weight: 2,
            fillOpacity: 0.2
        }
    }).eachLayer(layer => {
        layer.feature = {
            type: 'Feature',
            properties: geoJSON.properties,
            geometry: geoJSON.geometry
        };
        const popupContent = 'Площа: ' + area.toFixed(4) + ' га';
        layer.bindPopup(popupContent);
        editableLayers.addLayer(layer);
    });
}

            function mergeSelectedPolygons() {
                if (selectedFeatures.size < 2) {
                    alert('Виберіть принаймні 2 полігони для об\'єднання');
                    return;
                }

                try {
                    let polygons = [];
                    selectedFeatures.forEach(featureId => {
                        editableLayers.eachLayer(layer => {
                            if (L.stamp(layer) === featureId) {
                                polygons.push(layer);
                            }
                        });
                    });

                    // Конвертуємо полігони в формат turf.js
                    const features = polygons.map(p => p.toGeoJSON());

                    // Об'єднуємо полігони
                    let union = features[0];
                    for (let i = 1; i < features.length; i++) {
                        union = turf.union(union, features[i]);
                    }

                    // Видаляємо старі полігони
                    polygons.forEach(p => editableLayers.removeLayer(p));

                    // Рахуємо площу нового полігону
                    const area = turf.area(union) / 10000; // конвертуємо в га
                    union.properties = {
                        "Площа розрахована": area.toFixed(4)
                    };

                    // Додаємо новий полігон
                    L.geoJSON(union, {
                        style: {
                            color: '#3388ff',
                            weight: 2,
                            fillOpacity: 0.2
                        }
                    }).eachLayer(layer => {
                        layer.feature = union;
                        const popupContent = 'Площа: ' + area.toFixed(4) + ' га';
                        layer.bindPopup(popupContent);
                        editableLayers.addLayer(layer);
                    });

                    clearSelection();
                } catch (error) {
                    alert('Помилка при об\'єднанні полігонів: ' + error.message);
                }
            }
                    
        // Функция переключения выделения
        function toggleFeatureSelection(layer, e) {
    if (e) { // Перевіряємо чи існує e
        L.DomEvent.stopPropagation(e);
    }

    const featureId = L.stamp(layer);

    if (selectedFeatures.has(featureId)) {
        // Знімаємо виділення
        selectedFeatures.delete(featureId);
        layer.setStyle({
            fillOpacity: 0.4,
            weight: 0.5,
            color: getColor(layer.feature.properties["Орендар"])
        });
    } else {
        // Додаємо виділення
        if (!isCtrlPressed) {
            // Якщо Ctrl не натиснуто - очищаємо попередні виділення
            clearSelection();
        }
        selectedFeatures.add(featureId);
        layer.setStyle({
            fillOpacity: 0.6,
            weight: 2,
            color: '#FFFF00'
        });
    }

    updateSelectionInfo();
}

        // Функция обновления информации о выделении
        function updateSelectionInfo() {
            
            // Множество для отслеживания уже обработанных комбинаций
            const processedParts = new Set();
            // Кадастровые номера и общая информация
            const uniqueFeatures = new Map();
            // Информация по арендаторам
            const tenantAreas = new Map();
            // Площади по статусам
            const statusAreas = new Map();
            
            // Перебираем выбранные объекты
            selectedFeatures.forEach(featureId => {
                Object.values(overlays).forEach(layerGroup => {
                    if (!layerGroup || typeof layerGroup.eachLayer !== 'function') return;
                    
                    layerGroup.eachLayer(layer => {
                        if (L.stamp(layer) !== featureId || !layer.feature || !layer.feature.properties) return;
                        
                        const props = layer.feature.properties;
                        if (props.type !== 'split') {
                            return;
                        }
                        
                        const kadNum = props["Кадастровий номер"];
                        const partArea = parseFloat(props["Площа частини"]) || 0;
                        const totalArea = parseFloat(props["Площа розрахована"]) || 0;
                        const tenant = props["Орендар частини"] || props["Орендар"] || "Без орендаря";
                        const status = props["Статус"] || "Не вказано";
                        
                        // Уникальный идентификатор комбинации
                        const partId = `${kadNum}_${tenant}_${status}`;
                        
                        if (processedParts.has(partId) || !kadNum || isNaN(partArea) || partArea <= 0) {
                            return; // Пропускаем уже обработанные или некорректные данные
                        }
                        
                        processedParts.add(partId);
                        
                        // Создаем или обновляем информацию по кадастровому номеру
                        if (!uniqueFeatures.has(kadNum)) {
                            uniqueFeatures.set(kadNum, {
                                totalArea: totalArea,
                                tenant: tenant,
                                tenantCounted: false
                            });
                        }
                        
                        // Добавляем арендатора если еще не учтен для этого участка
                        if (!tenantAreas.has(tenant)) {
                            tenantAreas.set(tenant, 0);
                        }
                        
                        const featInfo = uniqueFeatures.get(kadNum);
                        if (!featInfo.tenantCounted) {
                            tenantAreas.set(tenant, tenantAreas.get(tenant) + totalArea);
                            featInfo.tenantCounted = true;
                        }
                        
                        // Добавляем площадь по статусу
                        if (!statusAreas.has(status)) {
                            statusAreas.set(status, 0);
                        }
                        statusAreas.set(status, statusAreas.get(status) + partArea);
                    });
                });
            });

            // Подсчитываем общую площадь участков
            const totalSelectedArea = Array.from(uniqueFeatures.values())
                .reduce((sum, info) => sum + info.totalArea, 0);
            
            // Подсчитываем общую площадь частей по статусам
            const totalPartsArea = Array.from(statusAreas.values())
                .reduce((sum, area) => sum + area, 0);

            // Обновляем интерфейс
            updateSelectionInfoUI(uniqueFeatures, tenantAreas, statusAreas, totalSelectedArea, totalPartsArea);
        }

        // Функция для обновления UI с инфобоксом о выделенных участках
        function updateSelectionInfoUI(uniqueFeatures, tenantAreas, statusAreas, totalSelectedArea, totalPartsArea) {
            const infoElement = document.getElementById('selectionInfo');
            const selectionTools = document.getElementById('selectionTools');
            
            if (uniqueFeatures.size === 0) {
                if (infoElement) infoElement.remove();
                if (selectionTools) selectionTools.style.display = 'none';
                return;
            }
            
            // Создаем инфобокс если его еще нет
            if (!infoElement) {
                const info = L.control({position: 'bottomleft'});
                info.onAdd = function() {
                    const div = L.DomUtil.create('div', 'selection-info');
                    div.id = 'selectionInfo';
                    div.style.background = 'white';
                    div.style.color = 'black';
                    div.style.padding = '6px';
                    div.style.border = '2px солід #666';
                    div.style.borderRadius = '4px';
                    div.style.maxWidth = '300px';
                    return div;
                };
                info.addTo(map);
            }
            
            // Формируем HTML для арендаторов
            let tenantsInfo = '';
            tenantAreas.forEach((area, tenant) => {
                const color = tenant === "Без орендаря" ? "#ffffff" : getColor(tenant);
                tenantsInfo += `
                    <div style="display: flex; align-items: center; margin-top: 3px;">
                        <span style="
                            display: inline-block;
                            width: 12px;
                            height: 12px;
                            margin-right: 5px;
                            background-color: ${color};
                            border: 1px solid #666;
                            border-radius: 2px;
                        "></span>
                        <span>${tenant}: ${area.toFixed(4)} га</span>
                    </div>`;
            });
            
            // Формируем HTML для статусов
            let statusInfo = '';
            statusAreas.forEach((area, status) => {
                const statusText = status.toLowerCase();
                const color = statusText === 'обробляється' ? '#198754' : 
                            statusText === 'не обробляється' ? '#dc3545' : 
                            '#666666';
                statusInfo += `
                    <div style="display: flex; align-items: center; margin-top: 3px;">
                        <span style="
                            display: inline-block;
                            width: 12px; 
                            height: 12px;
                            margin-right: 5px;
                            background-color: ${color};
                            border: 1px solid #666;
                            border-radius: 2px;
                        "></span>
                        <span>${status}: ${area.toFixed(4)} га</span>
                    </div>`;
            });
            
            // Обновляем содержимое инфобокса
            document.getElementById('selectionInfo').innerHTML = `
                <div style="max-height: 300px; overflow-y: auto;">
                    <div>
                        <b>Виділено ділянок:</b> ${uniqueFeatures.size}<br>
                        <div style="margin-top: 3px;">
                            <b>Загальна площа:</b> ${totalSelectedArea.toFixed(4)} га
                        </div>
                    </div>
                    <hr style="margin: 4px 0">
                    <div>
                        <strong>Розподіл по орендарях:</strong>
                        ${tenantsInfo}
                    </div>
                    <hr style="margin: 4px 0">
                    <div>
                        <strong>Розподіл за статусами:</strong>
                        ${statusInfo}
                    </div>
                    <div style="margin-top: 3px; font-size: 0.9em; color: #666; text-align: right;">
                        Площа частин: ${totalPartsArea.toFixed(4)} га
                    </div>
                </div>`;
            
            // Показываем инструменты выделения
            if (selectionTools) {
                selectionTools.style.display = 'block';
            }
        }

        // Модифицируем функцию initMap
        function initMap() {
            // Добавляем базовые слои
            const googleLayer = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                maxZoom: 20,
                attribution: '&copy; <a href="https://www.google.com/maps">Google</a>'
            }).addTo(map);

            const openStreetMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            });

            const rasterLayer = L.tileLayer(dataPath + 'tiles/sat/{z}/{x}/{y}.png', {
                maxZoom: 20,
                attribution: 'Актуальні растри'
            });

            // Инициализируем базовые слои глобально
            baseMaps = {
                "Google Maps": googleLayer,
                "OpenStreetMap": openStreetMapLayer,
                "Актуальні растри": rasterLayer
            };

            // Добавляем контроль локации
            L.control.locate({
                position: 'bottomright',
                strings: {
                    title: "Показати моє місцезнаходження"
                },
                locateOptions: {
                    enableHighAccuracy: true,
                    maxZoom: 20,
                    timeout: 10000,
                    maximumAge: 0,
                    watch: true
                },
            }).addTo(map);

            var baseMaps = {
                "Google Maps": googleLayer,
                "OpenStreetMap": openStreetMapLayer,
                "Актуальні растри": rasterLayer
            };

            freeLayer = L.layerGroup();

            // Добавляем контроль слоев
            layersControl = L.control.layers(baseMaps, overlays, {
                collapsed: true
            }).addTo(map);

            // Инициализируем остальные компоненты
            loadFileList();
            addFieldLayer();

            // Добавляем обработчики клавиш
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Control') {
                    isCtrlPressed = true;
                }
            });
            
            document.addEventListener('keyup', function(e) {
                if (e.key === 'Control') {
                    isCtrlPressed = false;
                }
            });

            // Обработчик клика по карте
            map.on('click', function(e) {
                if (!isCtrlPressed && !e.originalEvent.target.closest('.leaflet-control-layers')) {
                    clearSelection();
                }
            });
        }

        function loadFileList() {
            fetch(dataPath + 'file_list.json')
                .then(response => response.json())
                .then(data => {
                    var select = document.getElementById('fileSelect');
                    select.innerHTML = '<option>Виберіть раду</option>';
                    data.files.forEach(file => {
                        var option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.replace('.geojson', '');
                        select.appendChild(option);
                    });
                })
                .catch(error => {
                    console.error('Error loading file list:', error);
                    alert('Помилка завантаження списку файлів');
                });
        }

        function addFieldLayer() {
            fetch(dataPath + 'field.geojson')
                .then(response => response.json())
                .then(data => {
                    fieldLayer = L.geoJSON(data, {
                        style: styleFieldFeature,
                        onEachFeature: function (feature, layer) {
                            if (feature.properties) {
                                var area = feature.properties.area || '';
                                var name = feature.properties.name || '';
                                var tooltipText = name + '\n' + area.toString() + ' га';
                                layer.bindTooltip(tooltipText, {
                                    permanent: true,
                                    direction: 'center',
                                    className: 'area-tooltip',
                                    opacity: 0
                                });
                            }   
                        }
                    }).addTo(map);

                    updateLabelsVisibility();

                    map.on('zoomend', function() {
                        updateLabelsVisibility();
                    });

                    overlays["Поля обробітку"] = fieldLayer;
                    var colorBox = '<span class="color-box" style="background-color:transparent; border: 2px solid yellow"></span>';
                    layersControl.addOverlay(fieldLayer, colorBox + '<span class="layer-name">Поля обробітку</span>');
                })
                .catch(error => console.error('Error loading Field GeoJSON data:', error));
        }
                    
        function styleFieldFeature(feature) {
            return {
                color: 'yellow',
                weight: 3,
                opacity: 1,
                fillOpacity: 0
            };
        }

        function updateLabelsVisibility() {
            var currentZoom = map.getZoom();
            if (fieldLayer) {
                fieldLayer.eachLayer(function (layer) {
                    const tooltip = layer.getTooltip();
                    if (tooltip) {
                        if (currentZoom >= 15 && currentZoom <= 18) {
                            tooltip.setOpacity(1);
                        } else {
                            tooltip.setOpacity(0);
                        }
                    }
                });
            }
        }

        function clearSelection() {
    selectedFeatures.forEach(featureId => {
        const layers = Object.values(overlays);
        layers.forEach(layerGroup => {
            layerGroup.eachLayer(layer => {
                if (L.stamp(layer) === featureId && layer.feature) {
                    layer.setStyle({
                        fillOpacity: 0.4,
                        weight: 0.5,
                        color: getColor(layer.feature.properties["Орендар"])
                    });
                }
            });
        });
    });

    selectedFeatures.clear();

    const infoElement = document.getElementById('selectionInfo');
    const selectionTools = document.getElementById('selectionTools');

    if (infoElement) {
        infoElement.remove();
    }
    if (selectionTools) {
        selectionTools.style.display = 'none';
    }
}

        // Инициализируем обработчик выбора файла
        document.getElementById('fileSelect').addEventListener('change', function() {
            var selectedFile = this.value;
            if (selectedFile && selectedFile !== 'Виберіть раду') {
                this.disabled = true;
                var loadingOption = document.createElement('option');
                loadingOption.text = 'Завантаження...';
                this.add(loadingOption, 0);
                this.value = 'Завантаження...';
                addGeoJsonLayer(dataPath + selectedFile, selectedFile)
                    .then(() => {
                        this.remove(0);
                        this.disabled = false;
                        this.value = selectedFile;
                    })
                    .catch(error => {
                        console.error('Error loading GeoJSON:', error);
                        alert('Помилка завантаження даних');
                        this.remove(0);
                        this.disabled = false;
                        this.value = 'Виберіть раду';
                    });
            }
        });

        async function addGeoJsonLayer(url, layerName) {
    clearOverlays();
    tenantAreas = {};
    freeArea = 0;
    selectedFeatures.clear(); // Очищаем выбранные объекты
    
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        // Загружаем все исходные данные
        const data = await response.json();
        originalGeoJsonData = data;
        
        // Фильтруем только split-части для отображения на карте
        const splitFeatures = data.features.filter(feature => 
            feature.properties && feature.properties.type === "split"
        );

        // Создаем новый объект FeatureCollection только с split-частями
        const filteredData = {
            type: "FeatureCollection",
            features: splitFeatures
        };

        // Строим слой GeoJSON из отфильтрованных данных
        var geoJsonLayer = L.geoJSON(filteredData, {
            style: styleFeature,
            onEachFeature: onEachFeature
        });

        // Обновляем списки для фильтрации
        updateFieldSelect(data);
        updateExpiryYearSelect(data);

        // Добавляем слой на карту
        map.fitBounds(geoJsonLayer.getBounds());
        overlays[layerName] = geoJsonLayer;
        geoJsonLayer.addTo(map);
        
        // Обновляем интерфейс
        updateLayersControl();
        addSearchControl(geoJsonLayer);
        updateDataFreshnessIndicator(filteredData);
        
        return true;
    } catch (error) {
        console.error('Error loading GeoJSON:', error);
        throw error;
    }
}

        function styleFeature(feature) {
            // Для split используем орендаря части если есть
            const tenant = feature.properties["Орендар частини"] || feature.properties["Орендар"];
            return {
                color: getColor(tenant),
                weight: 0.5,
                opacity: 1,
                fillOpacity: 0.4
            };
        }

        function getColor(tenant) {
            if (!tenant) return "#ffffff";
            if (!tenantColors[tenant]) {
                tenantColors[tenant] = predefinedColors[colorIndex % predefinedColors.length];
                colorIndex++;
            }
            return tenantColors[tenant];
        }

        function onEachFeature(feature, layer) {
    if (feature.properties) {
        // Проверяем тип объекта и логируем
        if (feature.properties.type !== 'split') {
            return;
        }
        
        createPopupContent(feature, layer);
        processAreaAndTenant(feature, layer);
        // Добавляем обработчик клика для выделения/ Додаємо e як другий параметр
        layer.on('click', function(e) {
            if (!e.originalEvent.target.closest('.leaflet-popup')) {
                toggleFeatureSelection(layer, e); // Додаємо e як другий параметр
            }
        });
    }
}

        function createPopupContent(feature, layer) {
            let popupContent = '<div class="popup-content"><table>';
            
            // Изменяем порядок отображения свойств
            const orderedKeys = [
                "Кадастровий номер",
                "Площа розрахована", // Общая площадь участка
                "Власник",
                "Орендар частини", 
                "Орендар",
                "Дата реєстрації оренди",
                "Дата завершення",
                "Вид обмеження",
                "Статус",
                "Площа частини" // Площадь части с определенным статусом
            ];
            
            // Обрабатываем каждое поле и добавляем в таблицу
            orderedKeys.forEach(key => {
                if (feature.properties.hasOwnProperty(key)) {
                    let value = feature.properties[key] || '';
                    
                    // Форматируем числовые значения площадей с точностью до 4 знаков
                    if ((key === "Площа розрахована" || key === "Площа частини") && !isNaN(parseFloat(value))) {
                        value = parseFloat(value).toFixed(4) + " га";
                    }
                    
                    popupContent += `<tr>
                        <td class="property-name">${key}:</td>
                        <td class="property-value">${value}</td>
                    </tr>`;
                }
            });
            
            popupContent += '</table>';
            
            // Получаем кадастровый номер один раз
            const cadastralNumber = feature.properties["Кадастровий номер"];
            if (cadastralNumber) {
                // И используем его здесь
                const publicUrl = 'https://e.land.gov.ua/back/cadaster/?cad_num=' + cadastralNumber;
                popupContent += createPopupLinks(publicUrl, feature.properties["Дата оновлення"]);
            }
            
            popupContent += '</div>';
            layer.bindPopup(popupContent, {maxWidth: 300});
        }
        
        // Добавляем дополнительные стили для подсказок в popup
        document.addEventListener('DOMContentLoaded', function() {
            // ...existing code...
            
            // Добавляем стиль для пояснений в popup
            const style = document.createElement('style');
            style.textContent = `
                .popup-content .text-muted {
                    color: #6c757d;
                    font-size: 0.85em;
                    font-style: italic;
                }
                
                /* Улучшаем внешний вид таблицы с площадями */
                .popup-content tr:has(.property-name:contains("Площа")) {
                    background-color: rgba(0,0,0,0.03);
                }
                
                /* Выделяем строку с площадью части, если она мала по сравнению с общей */
                .popup-content tr.small-part {
                    background-color: rgba(255,243,205,0.5);
                }
            `;
            document.head.appendChild(style);
        });
        
        function processAreaAndTenant(feature, layer) {
            // Для split используем орендаря части
            const tenant = feature.properties["Орендар частини"] || feature.properties["Орендар"];
            const selectedField = document.getElementById('fieldSelect').value;
            
            // Для split используем Площа частини
            const area = parseFloat(feature.properties["Площа частини"]);
            
            // Определяем нужно ли считать эту часть
            let shouldCount = false;
            
            if (selectedField) {
                // Если выбрано конкретное поле, считаем только части с соответствующей Назва поля
                shouldCount = (feature.properties["Назва поля"] === selectedField);
            } else {
                // Если поле не выбрано, считаем все split-части
                shouldCount = true;
            }
            
            // Добавляем площадь только если нужно считать эту часть
            if (shouldCount && !isNaN(area)) {
                if (!tenant) {
                    freeLayer.addLayer(layer);
                    freeArea += area;
                } else {
                    if (!tenantAreas[tenant]) tenantAreas[tenant] = 0;
                    tenantAreas[tenant] += area;
                }
            }
        }

        // Предопределенные цвета
        const predefinedColors = [
            "#E44754", "#1B9688", "#ff9947", "#FAC1FA", "#9BBFF8",
            "#95F1FA", "#C6F8BD", "#F7FAB2", "#FFD7A6", "#FDABAB",
            "#A569BD", "#FF5733", "#4A235A", "#7DCEA0", "#E74C3C",
            "#F5B041", "#2471A3", "#AF7AC5", "#58D68D", "#5DADE2"
        ];
        let colorIndex = 0;

        function clearOverlays() {
            for (var layerName in overlays) {
                if (overlays.hasOwnProperty(layerName) && layerName !== "Поля обробітку") {
                    map.removeLayer(overlays[layerName]);
                }
            }
            var fieldLayerTemp = overlays["Поля обробітку"];
            overlays = {};
            if (fieldLayerTemp) {
                overlays["Поля обробітку"] = fieldLayerTemp;
            }
        }

        function updateLayersControl() {
    if (layersControl) {
        map.removeControl(layersControl);
    }
    const allLayers = {...baseMaps, ...overlays};
    layersControl = L.control.layers(null, allLayers, {
        collapsed: true
    }).addTo(map);
    addTenantLayers();
    addFreeLayer();
}

        function addTenantLayers() {
            var tenantLayers = {};
            var selectedField = document.getElementById('fieldSelect').value;
            
            // Спочатку очищаємо попередні дані
            tenantAreas = {};
            Object.values(overlays).forEach(layerGroup => {
                if (layerGroup && typeof layerGroup.eachLayer === 'function') {
                    layerGroup.eachLayer(layer => {
                        if (!layer.feature || !layer.feature.properties) return;
                        
                        // Используем "Орендар частини" или "Орендар"
                        const tenant = layer.feature.properties["Орендар частини"] || 
                                     layer.feature.properties["Орендар"];
                        
                        // Используем "Площа частини" для split
                        const area = parseFloat(layer.feature.properties["Площа частини"]);
                        
                        let shouldCount = false;
                        if (selectedField) {
                            // Если поле выбрано, учитываем только части с соответствующей Назва поля
                            shouldCount = (layer.feature.properties["Назва поля"] === selectedField);
                        } else {
                            // Если поле не выбрано, учитываем все split-части
                            shouldCount = true;
                        }
                        
                        if (tenant && !isNaN(area) && shouldCount) {
                            if (!tenantLayers[tenant]) {
                                tenantLayers[tenant] = L.layerGroup();
                                tenantAreas[tenant] = 0;
                            }
                            tenantAreas[tenant] += area;
                            tenantLayers[tenant].addLayer(layer);
                        }
                    });
                }
            });

            // Сортуємо орендарів за площею
            var sortedTenants = Object.entries(tenantAreas)
                .sort(([,a], [,b]) => b - a)
                .map(([tenant]) => tenant);

            // Додаємо шари в потрібному порядку
            sortedTenants.forEach(tenant => {
                overlays[tenant] = tenantLayers[tenant];
                var colorBox = `<span class="color-box" style="background-color:${getColor(tenant)}"></span>`;
                layersControl.addOverlay(tenantLayers[tenant], 
                    colorBox + `<span class="layer-name">${tenant} (${tenantAreas[tenant].toFixed(2)} га)</span>`);
                tenantLayers[tenant].addTo(map);
            });
        }

        function addFreeLayer() {
            if (freeLayer.getLayers().length > 0) {
                overlays["вільні від оренди"] = freeLayer;
                var colorBox = '<span class="color-box" style="background-color:#ffffff"></span>';
                layersControl.addOverlay(freeLayer, colorBox + `<span class="layer-name">вільні від оренди (${freeArea.toFixed(2)} га)</span>`);
            }
        }

        function updateFieldSelect(data) {
            var fieldSelect = document.getElementById('fieldSelect');
            fieldSelect.innerHTML = '<option value="">Всі поля</option>';
            var uniqueFields = new Set();
            data.features.forEach(feature => {
                // Собираем названия полей только из split-частей
                if (feature.properties?.type === 'split' && feature.properties?.['Назва поля']) {
                    uniqueFields.add(feature.properties['Назва поля']);
                }
            });
            Array.from(uniqueFields).sort().forEach(fieldName => {
                var option = document.createElement('option');
                option.value = fieldName;
                option.textContent = fieldName;
                fieldSelect.appendChild(option);
            });
        }

        function createPopupLinks(publicUrl, updateDate) {
            let content = '<div class="popup-link d-flex justify-content-between align-items-center">';
            content += `<a href="${publicUrl}" target="_blank" title="інформація з сервісів ДЗК">`;
            content += '<i class="bi bi-info-circle"></i></a>';
            content += '<div class="text-end">';
            if (updateDate) {
                const [day, month, year] = updateDate.split('.').map(Number);
                const updateDateTime = new Date(year, month - 1, day);
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                content += updateDate;
                if (updateDateTime < twoMonthsAgo) {
                    content += ' <i class="bi bi-exclamation-triangle-fill text-warning" ' +
                              'title="Інформація може бути застарілою"></i>';
                }
            }
            content += '</div></div>';
            return content;
        }

        function addSearchControl(layer) {
            if (searchControl) {
                map.removeControl(searchControl);
            }
            searchControl = new L.Control.Search({
                layer: layer,
                propertyName: '_searchField',
                initial: false,
                textPlaceholder: 'Пошук за кадастровим номером або власником',
                filterData: function(text, records) {
                    var jsons = records;
                    var ret = {};
                    
                    text = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    var reg = new RegExp(text, 'i');
                    
                    for (var i in jsons) {
                        try {
                            var props = jsons[i].layer.feature?.properties || {};
                            var kadastrovyNomer = props['Кадастровий номер'] || '';
                            var vlasnyk = props['Власник'] || '';
                            if (reg.test(kadastrovyNomer) || reg.test(vlasnyk)) {
                                ret[i] = jsons[i];
                            }   
                        } catch (error) {
                            console.error('Помилка при обробці об\'єкта:', error, jsons[i]);
                        }       
                    }
                    return ret;
                },
                buildTip: function(text, val) {
                    try {
                        var props = val.layer.feature?.properties || {};
                        var kadastrovyNomer = props['Кадастровий номер'] || 'Не вказано';
                        var vlasnyk = props['Власник'] || 'Не вказано';
                        return '<a href="#">Кадастровий номер: ' + kadastrovyNomer + '<br>Власник: ' + vlasnyk + '</a>';
                    } catch (error) {
                        console.error('Помилка при створенні підказки:', error);
                        return '<a href="#">Помилка: неможливо відобразити дані</a>';
                    }
                },
                moveToLocation: function(latlng, title, map) {
                    if (latlng.layer && latlng.layer.getBounds) {
                        map.fitBounds(latlng.layer.getBounds());
                    } else {
                        map.setView(latlng, 15);
                    }
                }
            }).addTo(map);

            // Обновляем поисковое поле для каждого объекта
            layer.eachLayer(function(layer) {
                if (layer.feature?.properties) {
                    const props = layer.feature.properties;
                    const searchField = `${props['Кадастровий номер'] || ''} ${props['Власник'] || ''}`;
                    layer.feature.properties._searchField = searchField;
                }
            });
        }

        function updateDataFreshnessIndicator(data) {
            const indicator = document.getElementById('dataFreshnessText');
            const icon = document.querySelector('.data-freshness-indicator i');
            const datesInfo = data.features.reduce((acc, f) => {
                const date = f.properties?.["Дата оновлення"];
                if (!date) {
                    acc.noDate++;
                    return acc;
                }
                const [day, month, year] = date.split('.').map(Number);
                const dateObj = new Date(year, month - 1, day);
                acc.dates.push(dateObj);
                return acc;
            }, { dates: [], noDate: 0 });
            const totalRecords = data.features.length;
            const { dates, noDate } = datesInfo;
            if (dates.length === 0 && noDate === totalRecords) {
                document.querySelector('.data-freshness-indicator').classList.add('freshness-бад');
                icon.title = `Записів без дати оновлення: ${noDate}`;
                return;
            }
            if (dates.length === 0 && noDate === 0) {
                indicator.textContent = 'Немає даних';
                icon.className = 'bi bi-clock-history text-light me-1';
                document.querySelector('.data-freshness-indicator').classList.remove('freshness-бад');
                return;
            }
            const now = new Date();
            const stats = dates.reduce((acc, date) => {
                const monthsOld = (now - date) / (1000 * 60 * 60 * 24 * 30);
                if (monthsOld < 1) acc.fresh++;
                else if (monthsOld < 2) acc.medium++;
                else acc.old++;
                return acc;
            }, { fresh: 0, medium: 0, old: 0 });
            const freshPercent = Math.round((stats.fresh / totalRecords) * 100);
            const mediumPercent = Math.round((stats.medium / totalRecords) * 100);
            const oldPercent = Math.round((stats.old / totalRecords) * 100);
            const noDatePercent = Math.round((noDate / totalRecords) * 100);
            let text, className;
            if (freshPercent >= 70) {
                text = `Актуально ${freshPercent}%`;
                className = 'freshness-good';
            } else if (freshPercent + mediumPercent >= 70) {
                text = `До 2 міс ${freshPercent + mediumPercent}%`;
                className = 'freshness-warning';
            } else {
                text = `Застаріло ${oldPercent}%`;
                className = 'freshness-бад';
                document.querySelector('.data-freshness-indicator').classList.add('freshness-бад');
            }
            if (className !== 'freshness-бад') {
                document.querySelector('.data-freshness-indicator').classList.remove('freshness-бад');
            }
            const tooltip = `Актуально (до 1 міс): ${freshPercent}%\n` +
                           `До 2 міс: ${mediumPercent}%\n` +
                           `Застаріло: ${oldPercent}%\n` +
                           `Без дати оновлення: ${noDatePercent}%`;
            indicator.textContent = text;
            indicator.title = tooltip;
            icon.className = `bi bi-clock-history me-1 ${className}`;
            icon.title = tooltip;
        }

        // Пример кнопки для быстрого снятия выделения (можно убрать при ненадобности)
        // function addClearSelectionButton() {
        //     const clearBtn = L.control({position: 'topleft'});
        //     clearBtn.onAdd = function() {
        //         const btn = L.DomUtil.create('button', 'btn btn-light');
        //         btn.innerText = 'Очистити виділення';
        //         L.DomEvent.on(btn, 'click', () => clearSelection());
        //         return btn;
        //     };
        //     clearBtn.addTo(map);
        // }

        // ...rest of your existing code...

        function exportSelectedToExcel() {
    const rows = [
        // Обновляем заголовки для split-данных
        ["Кадастровий номер", "Площа частини", "Власник", "Орендар частини", "Орендар", "Статус"]
    ];
    const uniqueFeatures = new Map();
    selectedFeatures.forEach(featureId => {
        Object.values(overlays).forEach(layerGroup => {
            layerGroup.eachLayer(layer => {
                if (L.stamp(layer) === featureId && layer.feature) {
                    const props = layer.feature.properties;
                    const kadNum = props["Кадастровий номер"];
                    if (kadNum && !uniqueFeatures.has(kadNum)) {
                        uniqueFeatures.set(kadNum, [
                            kadNum,
                            props["Площа частини"] || "",
                            props["Власник"] || "",
                            props["Орендар частини"] || "",
                            props["Орендар"] || "",
                            props["Статус"] || ""
                        ]);
                    }
                }
            });
        });
    });
    uniqueFeatures.forEach(row => rows.push(row));
    if (rows.length < 2) {
        alert("Немає даних для експорту");
        return;
    }
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, "Selected");
    XLSX.writeFile(wb, "виділені ділянки.xlsx");
}

        // После объявления глобальных переменных добавить:
        cadastralModal = document.getElementById("cadastralModal");
        let closeBtn = document.getElementsByClassName("close")[0];

        // Добавить обработчики событий для кнопок
        document.getElementById('cadastralSearchButton').addEventListener('click', function() {
            clearCadastralLists();
            cadastralModal.style.display = "block";
        });

        document.getElementById('exportButton').addEventListener('click', function() {
            var offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('mainMenu'));
            offcanvas.hide();
            setTimeout(() => {
                var data = collectMapData();
                var selectedFile = document.getElementById('fileSelect').value;
                if (data.length > 0) {
                    var filename = selectedFile.replace('.geojson', '');
                    exportToExcel(data, filename);
                } else {
                    alert('Немає даних для експорту. Будь ласка, виберіть файл з даними спочатку.');
                }
            }, 300);
        });

        document.getElementById('statisticsButton').addEventListener('click', function() {
            var selectedFile = document.getElementById('fileSelect').value;
            if (selectedFile && selectedFile !== 'Виберіть раду') {
                const urlParams = new URLSearchParams(window.location.search);
                const id = urlParams.get('id');
                const statisticsUrl = `statistics.html?file=${encodeURIComponent(selectedFile)}${id ? `&id=${id}` : ''}`;
                window.location.href = statisticsUrl;
            } else {
                alert('Будь ласка, спочатку виберіть файл з даними.');
            }
        });

        // Добавить функции для работы с модальным окном кадастровых номеров
        closeBtn.onclick = function() {
            cadastralModal.style.display = "none";
            clearCadastralLists();
        }
        window.onclick = function(event) {
            if (event.target == cadastralModal) {
                cadastralModal.style.display = "none";
                clearCadastralLists();
            }
        }

        function clearCadastralLists() {
            document.getElementById("ownCadastralList").value = '';
            document.getElementById("othersCadastralList").value = '';
        }

        // Добавить функцию для сбора данных карты
        function collectMapData() {
            var data = [];
            var selectedFile = document.getElementById('fileSelect').value;
            if (originalGeoJsonData && originalGeoJsonData.features) {
                // Використовуємо оригінальні дані замість overlays
                originalGeoJsonData.features.forEach(feature => {
                    if (feature.properties && 
                        (!feature.properties.type || feature.properties.type === 'original')) {
                        data.push(feature.properties);
                    }
                });
            }
            return data;
        }

        // Добавить обработчик поиска кадастровых номеров
        document.getElementById('searchCadastral').addEventListener('click', function() {
            var ownCadastralText = document.getElementById("ownCadastralList").value;
            var othersCadastralText = document.getElementById("othersCadastralList").value;
            if (!ownCadastralText && !othersCadastralText) {
                alert('Будь ласка, введіть хоча б один кадастровий номер');
                return;
            }
            var ownNumbers = ownCadastralText.split('\n')
                .map(num => num.trim())
                .filter(num => num.length > 0);
            var othersNumbers = othersCadastralText.split('\n')
                .map(num => num.trim())
                .filter(num => num.length > 0);

            // Очищаємо попередні маркери
            ownMarkersLayer.clearLayers();
            othersMarkersLayer.clearLayers();
            
            var foundFeatures = new Map();
            Object.values(overlays).forEach(layerGroup => {
                if (layerGroup && typeof layerGroup.eachLayer === 'function') {
                    layerGroup.eachLayer(layer => {
                        if (layer.feature && layer.feature.properties) {
                            var kadNum = layer.feature.properties['Кадастровий номер'];
                            if (kadNum && !foundFeatures.has(kadNum)) {
                                var isOwn = ownNumbers.includes(kadNum);
                                var isOther = othersNumbers.includes(kadNum);
                                if (isOwn || isOther) {
                                    foundFeatures.set(kadNum, layer);
                                    var center = getPolygonCenter(layer);
                                    var marker = createMarker(center, kadNum, isOwn);
                                    marker.bindPopup(`
                                        <div style="font-size: 14px; font-weight: bold;">
                                            ${kadNum}
                                            <br>
                                            <span style="color: ${isOwn ? '#28a745' : '#dc3545'}">
                                                ${isOwn ? 'Своя ділянка' : 'Чужа ділянка'}
                                            </span>
                                        </div>
                                    `, {
                                        offset: [0, -20]
                                    });
                                    
                                    marker.addTo(isOwn ? ownMarkersLayer : othersMarkersLayer);
                                }
                            }         
                        }
                    });
                }                     
            });

            if (foundFeatures.size > 0) {
                var group = L.featureGroup([ownMarkersLayer, othersMarkersLayer]);
                map.fitBounds(group.getBounds(), {
                    padding: [50, 50]
                });
                
                alert(`Знайдено ${foundFeatures.size} ділянок`);
                cadastralModal.style.display = "none";
                clearCadastralLists();
            } else {
                alert('Ділянок не знайдено');
            }     
        });

        function createMarker(center, kadNum, isOwn) {
            var color = isOwn ? '#28a745' : '#dc3545';
            return L.marker(center, {
                icon: L.divIcon({
                    className: 'custom-div-icon',
                    html: `
                        <div style="
                            background-color: ${color};
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            border: 3px солід white;
                            box-shadow: 0 0 4px rgba(0,0,0,0.5);
                            animation: pulse 2s infinite;
                        "></div>
                    `,
                    iconSize: [10, 10],
                    iconAnchor: [5, 5]
                })
            });
        }

        // Добавляем функцию exportToExcel
        function exportToExcel(data, filename) {
            // Если данных нет, выводим ошибку
            if (data.length === 0) {
                alert('Немає даних для експорту. Перевірте, що на карті є відображені об\'єкти.');
                return;
            }
            
            // Сортируем по кадастровому номеру
            data.sort((a, b) => {
                const kadNumA = a["Кадастровий номер"] || "";
                const kadNumB = b["Кадастровий номер"] || "";
                return kadNumA.localeCompare(kadNumB);
            });
            
            // Приоритетные поля для отображения в начале
            const priorityKeys = [
                "Кадастровий номер",
                "Площа розрахована",
                "Площа частини", 
                "Власник",
                "Орендар частини",
                "Орендар",
                "Дата реєстрації оренди",
                "Дата завершення",
                "Назва поля",
                "Статус"
            ];
            
            // Собираем все уникальные ключи из данных
            const allKeys = new Set();
            data.forEach(item => {
                Object.keys(item).forEach(key => {
                    // Исключаем служебное поле type
                    if (key !== 'type') {
                        allKeys.add(key);
                    }
                });
            });
            
            // Формируем заголовки с приоритезацией
            const headers = [];
            
            // Сначала добавляем приоритетные поля
            priorityKeys.forEach(key => {
                if (allKeys.has(key)) {
                    headers.push(key);
                    allKeys.delete(key);
                }
            });
            
            // Затем добавляем остальные поля по алфавиту
            Array.from(allKeys).sort().forEach(key => {
                headers.push(key);
            });
            
            // Создаем строки для Excel
            const rows = [headers];
            data.forEach(item => {
                const row = headers.map(header => item[header] || "");
                rows.push(row);
            });
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);
            XLSX.utils.book_append_sheet(wb, ws, "Ділянки");
            XLSX.writeFile(wb, filename + ".xlsx");
        }

        // Добавляем функцию searchCadastralNumbers
        function searchCadastralNumbers() {
            var ownCadastralText = document.getElementById("ownCadastralList").value;
            var othersCadastralText = document.getElementById("othersCadastralList").value;
            
            if (!ownCadastralText && !othersCadastralText) {
                alert('Будь ласка, введіть хоча б один кадастровий номер');
                return;
            }

            var ownNumbers = ownCadastralText.split('\n')
                .map(num => num.trim())
                .filter(num => num.length > 0);
            var othersNumbers = othersCadastralText.split('\n')
                .map(num => num.trim())
                .filter(num => num.length > 0);

            // Очищаємо попередні маркери
            ownMarkersLayer.clearLayers();
            othersMarkersLayer.clearLayers();
            
            var foundFeatures = new Map();
            
            Object.values(overlays).forEach(layerGroup => {
                if (layerGroup && typeof layerGroup.eachLayer === 'function') {
                    layerGroup.eachLayer(layer => {
                        if (layer.feature && layer.feature.properties) {
                            var kadNum = layer.feature.properties['Кадастровий номер'];
                            
                            if (kadNum && !foundFeatures.has(kadNum)) {
                                var isOwn = ownNumbers.includes(kadNum);
                                var isOther = othersNumbers.includes(kadNum);
                                if (isOwn || isOther) {
                                    foundFeatures.set(kadNum, layer);
                                    var center = getPolygonCenter(layer);
                                    var marker = createMarker(center, kadNum, isOwn);
                                    marker.bindPopup(`
                                        <div style="font-size: 14px; font-weight: bold;">
                                            ${kadNum}
                                            <br>
                                            <span style="color: ${isOwn ? '#28a745' : '#dc3545'}">
                                                ${isOwn ? 'Своя ділянка' : 'Чужа ділянка'}
                                            </span>
                                        </div>
                                    `, {
                                        offset: [0, -20]
                                    });
                                    
                                    marker.addTo(isOwn ? ownMarkersLayer : othersMarkersLayer);
                                }
                            }
                        }
                    });
                }                     
            });

            if (foundFeatures.size > 0) {
                var group = L.featureGroup([ownMarkersLayer, othersMarkersLayer]);
                map.fitBounds(group.getBounds(), {
                    padding: [50, 50]
                });
                
                alert(`Знайдено ${foundFeatures.size} ділянок`);
                cadastralModal.style.display = "none";
                clearCadastralLists();
            } else {
                alert('Ділянок не знайдено');
            }     
        }

        function calculatePolygonArea(layer) {
            var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
            return (area / 10000).toFixed(4); // Перевод в гектары
        }

        function updateAreaPopup(layer) {
            var areaInHectares = calculatePolygonArea(layer);
            layer.setPopupContent('Площа: ' + areaInHectares + ' га');
        }

        function exportToGeoJSON() {
            var modal = document.getElementById('exportModal');
            var span = modal.getElementsByClassName("close")[0];
            var confirmBtn = document.getElementById('confirmExport');
            var filenameInput = document.getElementById('exportFilename');
            var formatSelect = document.getElementById('exportFormat');
            var polygonsList = document.getElementById('polygonsList');

            var defaultFilename = 'polygons_' + new Date().toISOString().slice(0,10);
            filenameInput.value = defaultFilename;
            polygonsList.innerHTML = '';
            var index = 1;
            editableLayers.eachLayer(function(layer) {
                if (layer instanceof L.Polygon) {
                    var area = calculatePolygonArea(layer);
                    var polygonItem = document.createElement('div');
                    polygonItem.className = 'list-group-item';
                    polygonItem.innerHTML = `
                        <div class="mb-2">
                            <strong>Полігон ${index} (${area} га)</strong>
                        </div>
                        <div class="form-group">
                            <textarea class="form-control polygon-note" 
                                     data-layer-id="${L.stamp(layer)}" 
                                     placeholder="Примітка для полігону ${index}..."
                                     rows="2"></textarea>
                        </div>
                    `;
                    polygonsList.appendChild(polygonItem);
                    index++;
                }
            });
            modal.style.display = "block";
            span.onclick = function() {
                modal.style.display = "none";
                filenameInput.value = '';
            }
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                    filenameInput.value = '';
                }
            }
            confirmBtn.onclick = function() {
                var geojson = editableLayers.toGeoJSON();
                var notesMap = {};
                document.querySelectorAll('.polygon-note').forEach(function(textarea) {
                    notesMap[textarea.dataset.layerId] = textarea.value;
                });
                geojson.features.forEach(function(feature, index) {
                    if (!feature.properties) {
                        feature.properties = {};
                    }
                    var layer = editableLayers.getLayers()[index];
                    var layerId = L.stamp(layer);
                    if (feature.geometry && feature.geometry.type === 'Polygon') {
                        feature.properties.note = notesMap[layerId] || '';
                        feature.geometry.coordinates[0].forEach(function(coord) {
                            let lat, lng;
                            [lng, lat] = coord;
                            return [lat, lng];
                        });
                        var area = L.GeometryUtil.geodesicArea(feature.geometry.coordinates[0].map(coord => L.latLng(coord[1], coord[0])));
                        feature.properties.area = (area / 10000).toFixed(4);
                    }
                });
                var filename = filenameInput.value || defaultFilename;
                var format = formatSelect.value;
                if (format === 'kml') {
                    if (!filename.endsWith('.kml')) filename += '.kml';
                    var kml = convertToKML(geojson);
                    var dataStr = "data:text/xml;charset=utf-8," + encodeURIComponent(kml);
                } else {
                    if (!filename.endsWith('.geojson')) filename += '.geojson';
                    var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geojson));
                }
                var downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", filename);
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
                modal.style.display = "none";
                filenameInput.value = '';
            }
        }

        function convertToKML(geojson) {
            var kml = '<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n';
            geojson.features.forEach(function(feature, index) {
                kml += '  <Placemark>\n';
                kml += '    <name>Полігон ' + (index + 1) + '</name>\n';
                kml += '    <description><![CDATA[';
                kml += 'Площа: ' + (feature.properties.area || '0') + ' га<br>';
                kml += 'Примітка: ' + (feature.properties.note || '');
                kml += ']]></description>\n';
                kml += '    <Style><LineStyle><color>ff000000</color><width>2</width></LineStyle>';
                kml += '<PolyStyle><color>4d0000ff</color></PolyStyle></Style>\n';
                if (feature.geometry && feature.geometry.type === 'Polygon') {
                    kml += '    <Polygon><outerBoundaryIs><LinearRing><coordinates>\n';
                    feature.geometry.coordinates[0].forEach(function(coord) {
                        kml += '      ' + coord[0] + ',' + coord[1] + ',0\n';
                    });
                    kml += '    </coordinates></LinearRing></outerBoundaryIs></Polygon>\n';
                }
                kml += '  </Placemark>\n';
            });
            kml += '</Document>\n</kml>';
            return kml;
        }

        // Додайте нові функції для завантаження файлів
        function showLoadModal() {
            var modal = document.getElementById('loadModal');
            var span = modal.getElementsByClassName("close")[0];
            var confirmBtn = document.getElementById('confirmLoad');
            var fileInput = document.getElementById('fileInput');
            span.onclick = function() {
                modal.style.display = "block";
                fileInput.value = '';
            }
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                    fileInput.value = '';
                }
            }
            confirmBtn.onclick = function() {
                var file = fileInput.files[0];
                var clearExisting = document.getElementById('clearExisting').checked;
                if (file) {
                    var reader = new FileReader();
                    reader.onload = function(e) {
                        loadPolygonsFromFile(e.target.result, file.name, clearExisting);
                    };
                    reader.readAsText(file);
                }
                modal.style.display = "none";
                fileInput.value = '';
            }
        }

        function loadPolygonsFromFile(content, filename, clearExisting) {       
    var data;
    try {
        if (filename.toLowerCase().endsWith('.kml')) {
            var parser = new DOMParser();
            var kml = parser.parseFromString(content, 'text/xml');
            data = toGeoJSON.kml(kml);
        } else {
            data = JSON.parse(content);
        }

        if (clearExisting) {
            editableLayers.clearLayers();
        }

        if (data.features && Array.isArray(data.features)) {
            let addedPolygons = 0;
            data.features.forEach(function(feature) {
                if (feature.geometry && 
                    (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                    try {
                        let polygonCoordinates = [];
                        if (feature.geometry.type === 'Polygon') {
                            polygonCoordinates = [feature.geometry.coordinates[0]];
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            polygonCoordinates = feature.geometry.coordinates[0];
                        }
                        polygonCoordinates.forEach((coordinates) => {
                            let latLngs = coordinates.map(coord => {
                                return L.latLng(coord[1], coord[0]); // Конвертуємо в latLng
                            });
                            
                            if (latLngs.length >= 3) {
                                const polygon = L.polygon(latLngs, {
                                    color: '#3388ff',
                                    weight: 2
                                });
                                
                                // Додаємо площу
                                const area = L.GeometryUtil.geodesicArea(latLngs);
                                const areaInHectares = (area / 10000).toFixed(4);
                                polygon.bindPopup('Площа: ' + areaInHectares + ' га');
                                
                                editableLayers.addLayer(polygon);
                                addedPolygons++;
                            }
                        });
                    } catch (e) {
                        console.error('Помилка при обробці полігону:', e);
                    }
                }
            });

            if (addedPolygons > 0) {
                map.fitBounds(editableLayers.getBounds(), {
                    padding: [50, 50]
                });
                alert(`Успішно завантажено ${addedPolygons} полігонів`);
            } else {
                alert('Не вдалося завантажити жодного полігону');
            }
        } else {
            alert('Файл має невірний формат');
        }
    } catch (error) {
        console.error('Помилка завантаження файлу:', error);
        alert('Помилка завантаження файлу. Перевірте формат файлу.');
    }
}

        function updateExpiryYearSelect(data) {
            var expiryYearSelect = document.getElementById('expiryYearSelect');
            expiryYearSelect.innerHTML = '<option value="">Всі роки</option>';
            expiryYearSelect.innerHTML += '<option value="no_date">Без дати</option>'; // Добавляем опцию "Без дати"
            var uniqueYears = new Set();
            data.features.forEach(feature => {
                // Собираем годы завершения только из split-частей
                if (feature.properties?.type === 'split' && feature.properties?.['Дата завершення']) {
                    const dateStr = feature.properties['Дата завершення'];
                    const year = dateStr.split('.')[2];
                    if (year) {
                        uniqueYears.add(year);
                    }
                }
            });
            Array.from(uniqueYears).sort().forEach(year => {
                var option = document.createElement('option');
                option.value = year;
                option.textContent = year + ' рік';
                expiryYearSelect.appendChild(option);
            });
        }

        // Модифицируем функцию фильтрации для корректной обработки записей без даты
        function filterByExpiryYear(feature, selectedYear) {
            if (selectedYear === '') return true; // Показать все записи
            if (selectedYear === 'no_date') {
                // Показать только записи без даты
                return !feature.properties?.['Дата завершення'];
            }
            if (feature.properties?.['Дата завершення']) {
                const dateStr = feature.properties['Дата завершення'];
                const year = dateStr.split('.')[2];
                return year === selectedYear;
            }
            return false;
        }

        // Обновляем обработчик изменения в списке годов
        document.getElementById('expiryYearSelect').addEventListener('change', function() {
            var selectedField = document.getElementById('fieldSelect').value;
            var selectedFile = document.getElementById('fileSelect').value;
            var selectedYear = this.value;
            if (selectedFile !== 'Виберіть раду' && originalGeoJsonData) {
                clearOverlays();
                tenantAreas = {};
                freeArea = 0;
                selectedFeatures.clear(); // Очищаем выделение при смене фильтра
                
                
                // Фильтруем только split-части
                const filteredFeatures = originalGeoJsonData.features.filter(feature => {
                    // Проверяем тип объекта
                    if (!feature.properties || feature.properties.type !== 'split') {
                        return false;
                    }
                    
                    // Проверяем соответствие полю
                    const fieldMatch = !selectedField || 
                        feature.properties['Назва поля'] === selectedField;
                    
                    // Проверяем соответствие году
                    let yearMatch = true;
                    if (selectedYear) {
                        if (selectedYear === 'no_date') {
                            yearMatch = !feature.properties['Дата завершення'];
                        } else if (feature.properties['Дата завершення']) {
                            const dateStr = feature.properties['Дата завершення'];
                            const year = dateStr.split('.')[2];
                            yearMatch = year === selectedYear;
                        } else {
                            yearMatch = false;
                        }
                    }
                    
                    return fieldMatch && yearMatch;
                });
                
                
                const filteredData = {
                    type: "FeatureCollection",
                    features: filteredFeatures
                };
                
                var geoJsonLayer = L.geoJSON(filteredData, {
                    style: styleFeature,
                    onEachFeature: onEachFeature
                });
                
                overlays[selectedFile] = geoJsonLayer;
                geoJsonLayer.addTo(map);
                
                if (geoJsonLayer.getBounds().isValid()) {
                    map.fitBounds(geoJsonLayer.getBounds());
                }
                
                updateLayersControl();
                addSearchControl(geoJsonLayer);
                updateDataFreshnessIndicator(filteredData);
            }
        });

        // Модифікуємо існуючий обробник зміни fieldSelect
        document.getElementById('fieldSelect').addEventListener('change', function() {
            var selectedField = this.value;
            var selectedFile = document.getElementById('fileSelect').value;
            var selectedYear = document.getElementById('expiryYearSelect').value;
            if (selectedFile !== 'Виберіть раду' && originalGeoJsonData) {
                clearOverlays();
                tenantAreas = {};
                freeArea = 0;
                selectedFeatures.clear(); // Очищаем выделение при смене фильтра
                
                
                // Фильтруем только split-части
                const filteredFeatures = originalGeoJsonData.features.filter(feature => {
                    // Проверяем тип объекта
                    if (!feature.properties || feature.properties.type !== 'split') {
                        return false;
                    }
                    
                    // Проверяем соответствие полю
                    const fieldMatch = !selectedField || 
                        feature.properties['Назва поля'] === selectedField;
                    
                    // Проверяем соответствие году (если выбран)
                    let yearMatch = true;
                    if (selectedYear) {
                        if (selectedYear === 'no_date') {
                            yearMatch = !feature.properties['Дата завершення'];
                        } else if (feature.properties['Дата завершення']) {
                            const dateStr = feature.properties['Дата завершення'];
                            const year = dateStr.split('.')[2];
                            yearMatch = year === selectedYear;
                        } else {
                            yearMatch = false;
                        }
                    }
                    
                    return fieldMatch && yearMatch;
                });
                
                
                const filteredData = {
                    type: "FeatureCollection",
                    features: filteredFeatures
                };
                
                var geoJsonLayer = L.geoJSON(filteredData, {
                    style: styleFeature,
                    onEachFeature: onEachFeature
                });
                
                overlays[selectedFile] = geoJsonLayer;
                geoJsonLayer.addTo(map);
                
                if (geoJsonLayer.getBounds().isValid()) {
                    map.fitBounds(geoJsonLayer.getBounds());
                }
                
                updateLayersControl();
                addSearchControl(geoJsonLayer);
                updateDataFreshnessIndicator(filteredData);
            }
        });

        // Додаємо обробники для кнопок виділення
        document.querySelector('[data-action="clear-selection"]')?.addEventListener('click', clearSelection);
        document.querySelector('[data-action="export-selected"]')?.addEventListener('click', exportSelectedToExcel);
    }; // Закрывающая скобка для обработчика DOMContentLoaded

    // Глобальные функции - добавить в начало скрипта, сразу после определения глобальных переменных
    function clearCadastralLists() {
        document.getElementById("ownCadastralList").value = '';
        document.getElementById("othersCadastralList").value = '';
    }

    function createMarker(center, kadNum, isOwn) {
        var color = isOwn ? '#28a745' : '#dc3545';
        return L.marker(center, {
            icon: L.divIcon({
                className: 'custom-div-icon',
                html: `
                    <div style="
                        background-color: ${color};
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        border: 3px solid white;
                        box-shadow: 0 0 4px rgba(0,0,0,0.5);
                        animation: pulse 2s infinite;
                    "></div>
                `,
                iconSize: [10, 10],
                iconAnchor: [5, 5]
            })
        });
    }

    // Функция для получения центра полигона
    function getPolygonCenter(layer) {
        if (layer.getBounds) {
            return layer.getBounds().getCenter();
        }
        // Если getBounds не доступен, вычисляем центр по координатам
        const latLngs = layer.getLatLngs()[0];
        const sumLat = latLngs.reduce((sum, point) => sum + point.lat, 0);
        const sumLng = latLngs.reduce((sum, point) => sum + point.lng, 0);
        return L.latLng(sumLat / latLngs.length, sumLng / latLngs.length);
    }

    // В функции searchCadastralNumbers заменить layer.getBounds().getCenter() на:
    // var center = getPolygonCenter(layer);

    // ...rest of your existing code...

    function getBoundsFromLayers(layers) {
        let bounds = null;
        layers.forEach(layer => {
            if (layer.getBounds) {
                const layerBounds = layer.getBounds();
                if (bounds === null) {
                    bounds = layerBounds;
                } else {
                    bounds.extend(layerBounds);
                }
            }
        });
        return bounds;
    }

document.getElementById('exchangeButton').addEventListener('click', function() {
    var offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('mainMenu'));
    offcanvas.hide();
    setTimeout(() => {
        document.getElementById('exchangeModal').style.display = "block";
    }, 300);
});

// Закриття модального вікна
document.querySelector('#exchangeModal .close').addEventListener('click', function() {
    document.getElementById('exchangeModal').style.display = "none";
});

// Формування таблиці обміну
document.getElementById('generateExchange').addEventListener('click', function() {
    const exchangeList = document.getElementById('exchangeList');
    const exchangeAnalysis = document.getElementById('exchangeAnalysis');
    const totalAreaElement = document.getElementById('totalArea');
    const exchangeTableContainer = document.getElementById('exchangeTableContainer');
    const fieldTablesContainer = document.getElementById('fieldTables');

    if (!exchangeList || !exchangeAnalysis || !totalAreaElement || 
        !exchangeTableContainer || !fieldTablesContainer) {
        alert('Виникла помилка при формуванні результатів');
        return;
    }

    const cadastralNumbers = exchangeList.value
        .split('\n')
        .map(num => num.trim())
        .filter(num => num.length > 0);

    if (cadastralNumbers.length === 0) {
        alert('Введіть хоча б один кадастровий номер');
        return;
    }

    if (!originalGeoJsonData) {
        alert('Дані не завантажені. Спочатку виберіть раду.');
        return;
    }

    // Фильтруем split-записи и группируем данные по арендатору
    const tenantGroups = new Map();
    let totalArea = 0;

    const splitFeatures = originalGeoJsonData.features.filter(feature => 
        cadastralNumbers.includes(feature.properties['Кадастровий номер']) &&
        feature.properties.type === 'split'
    );

    if (splitFeatures.length === 0) {
        alert('Не знайдено ділянок для обміну');
        return;
    }

    splitFeatures.forEach(feature => {
        const props = feature.properties;
        const tenant = props['Орендар частини'] || props['Орендар'] || 'Без орендаря';
        const cadastral = props['Кадастровий номер'];
        const splitArea = parseFloat(props['Площа частини']) || 0;
        const status = props['Статус'] || 'Не визначено';
        
        if (!tenantGroups.has(tenant)) {
            tenantGroups.set(tenant, {
                parcels: new Map(),
                totalArea: 0,
                areaByStatus: {}
            });
        }

        const tenantData = tenantGroups.get(tenant);
        if (!tenantData.parcels.has(cadastral)) {
            tenantData.parcels.set(cadastral, {
                fullArea: parseFloat(props['Площа розрахована']) || 0,
                splits: [],
                statusAreas: {}
            });
        }

        const parcelData = tenantData.parcels.get(cadastral);
        parcelData.splits.push({
            area: splitArea,
            status: status,
            expiry: props['Дата завершення'] || '-'
        });

        parcelData.statusAreas[status] = (parcelData.statusAreas[status] || 0) + splitArea;
        tenantData.areaByStatus[status] = (tenantData.areaByStatus[status] || 0) + splitArea;
        tenantData.totalArea += splitArea;
        totalArea += splitArea;
    });

    // Очищаем контейнеры перед заполнением
    fieldTablesContainer.innerHTML = '';
    exchangeAnalysis.innerHTML = '';
    
    // Собираем все уникальные статусы
    const allStatuses = new Set();
    tenantGroups.forEach(tenantData => {
        Object.keys(tenantData.areaByStatus).forEach(status => allStatuses.add(status));
    });
    const sortedStatuses = Array.from(allStatuses).sort();

    // Формируем таблицы для каждого арендатора
    const sortedTenants = Array.from(tenantGroups.keys()).sort();
    sortedTenants.forEach(tenant => {
        const tenantData = tenantGroups.get(tenant);
        const tenantGroup = document.createElement('div');
        tenantGroup.className = 'tenant-group mb-4';
        
        // Заголовок группы
        const header = document.createElement('h5');
        header.textContent = tenant;
        tenantGroup.appendChild(header);

        // Создаем таблицу
        const table = document.createElement('table');
        table.className = 'table table-sm';
        
        // Заголовки таблицы
        const thead = document.createElement('thead');
        thead.innerHTML = `<tr>
            <th>Кадастровий номер</th>
            <th>Площа розрахована</th>
            ${sortedStatuses.map(status => {
                const statusText = status.toLowerCase();
                const color = statusText === 'обробляється' ? '#198754' : 
                             statusText === 'не обробляється' ? '#dc3545' : 
                             '#000000';
                return `<th style="color: ${color}">${status}</th>`;
            }).join('')}
            <th>Дата завершення</th>
        </tr>`;
        table.appendChild(thead);

        // Тело таблицы
        const tbody = document.createElement('tbody');
        tenantData.parcels.forEach((parcelData, cadastral) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${cadastral}</td>
                <td>${parcelData.fullArea.toFixed(4)}</td>
                ${sortedStatuses.map(status => 
                    `<td>${parcelData.statusAreas[status]?.toFixed(4) || '0.0000'}</td>`
                ).join('')}
                <td>${parcelData.splits[0]?.expiry || '-'}</td>
            `;
            tbody.appendChild(tr);
        });
        table.appendChild(tbody);

        // Итоговая строка
        const tfoot = document.createElement('tfoot');
        const footerRow = document.createElement('tr');
        footerRow.innerHTML = `
            <td><strong>Всього:</strong></td>
            <td><strong>${tenantData.totalArea.toFixed(4)}</strong></td>
            ${sortedStatuses.map(status => {
                const statusText = status.toLowerCase();
                const color = statusText === 'обробляється' ? '#198754' : 
                             statusText === 'не обробляється' ? '#dc3545' : 
                             '#000000';
                return `<td><strong style="color: ${color}">${tenantData.areaByStatus[status]?.toFixed(4) || '0.0000'}</strong></td>`;
            }).join('')}
            <td></td>
        `;
        tfoot.appendChild(footerRow);
        table.appendChild(tfoot);

        tenantGroup.appendChild(table);
        fieldTablesContainer.appendChild(tenantGroup);
    });

    // Обновляем общую площадь
    totalAreaElement.textContent = totalArea.toFixed(4);

    // Анализ равноценности обмена
    if (tenantGroups.size > 1) {
        const areas = Array.from(tenantGroups.entries());
        const maxDiffPercent = 5;

        for (let i = 0; i < areas.length; i++) {
            for (let j = i + 1; j < areas.length; j++) {
                const [tenant1, data1] = areas[i];
                const [tenant2, data2] = areas[j];
                
                const area1 = data1.totalArea;
                const area2 = data2.totalArea;
                const diff = Math.abs(area1 - area2);
                const avgArea = (area1 + area2) / 2;
                const diffPercent = (diff / avgArea) * 100;

                const analysisDiv = document.createElement('div');
                const comparison = `${tenant1} ↔ ${tenant2}:<br>` +
                    `${area1.toFixed(4)} га ↔ ${area2.toFixed(4)} га<br>` +
                    `(різниця: ${diff.toFixed(4)} га, ${diffPercent.toFixed(1)}%)<br>`;

                if (diffPercent > maxDiffPercent) {
                    analysisDiv.className = 'text-danger';
                    analysisDiv.innerHTML = `❌ ${comparison}Обмін НЕ рівноцінний`;
                } else {
                    analysisDiv.className = 'text-success';
                    analysisDiv.innerHTML = `✓ ${comparison}Обмін рівноцінний`;
                }

                exchangeAnalysis.appendChild(analysisDiv);
            }
        }
    } else {
        const warningDiv = document.createElement('div');
        warningDiv.className = 'text-danger';
        warningDiv.textContent = 'Недостатньо даних для аналізу (потрібно як мінімум два орендаря)';
        exchangeAnalysis.appendChild(warningDiv);
    }

    // Показываем результаты
    fieldTablesContainer.style.display = 'block';
    exchangeTableContainer.style.display = 'block';
});

// ...existing code...
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
<script>
document.getElementById('exportPDF').addEventListener('click', function() {
    const exchangeAnalysis = document.getElementById('exchangeAnalysis');
    const totalArea = document.getElementById('totalArea').textContent;
    const fieldTables = document.getElementById('fieldTables');

    if (!exchangeAnalysis || !totalArea || !fieldTables) {
        alert('Спочатку сформуйте дані для обміну');
        return;
    }

    const documentDefinition = {
        pageSize: 'A4',
        pageOrientation: 'landscape',
        content: [
            {
                text: 'ПРОПОЗИЦІЯ ОБМІНУ ЗЕМЕЛЬНИМИ ДІЛЯНКАМИ',
                style: 'header',
                alignment: 'center'
            },
            {
                text: `Дата формування: ${new Date().toLocaleDateString('uk-UA')}`,
                style: 'date',
                margin: [0, 10, 0, 20]
            }
        ],
        styles: {
            header: {
                fontSize: 16,
                bold: true,
                margin: [0, 0, 0, 10]
            },
            date: {
                fontSize: 12,
                margin: [0, 5, 0, 15]
            },
            tenantHeader: {
                fontSize: 14,
                bold: true,
                margin: [0, 15, 0, 5]
            },
            tableHeader: {
                bold: true,
                fontSize: 9,
                fillColor: '#f8f9fa'
            },
            tableFooter: {
                bold: true,
                fontSize: 9
            }
        },
        // Уменьшаем отступы страницы для максимального использования пространства
        pageMargins: [15, 20, 15, 20],
        defaultStyle: {
            fontSize: 9,
            lineHeight: 1.2
        }
    };

    // Собираем информацию по каждому участнику обмена
    const tenantGroups = document.querySelectorAll('#fieldTables .tenant-group');
    tenantGroups.forEach((group, index) => {
        const tenantName = group.querySelector('h5').textContent;
        const table = group.querySelector('table');
        
        if (table) {
            // Заголовок группы
            documentDefinition.content.push({
                text: tenantName,
                style: 'tenantHeader'
            });

            // Формируем таблицу
            const headerRow = Array.from(table.querySelectorAll('thead th'))
                .map((th, index) => {
                    const text = th.textContent;
                    const statusText = text.toLowerCase();
                    return {
                        text: text,
                        style: 'tableHeader',
                        color: statusText === 'обробляється' ? '#198754' : 
                               statusText === 'не обробляється' ? '#dc3545' : 
                               '#000000',
                        noWrap: false
                    };
                });

            // Подсчитываем максимальную длину текста в каждой колонке
            const columnLengths = Array(headerRow.length).fill(0);
            
            // Учитываем длину заголовков
            headerRow.forEach((header, index) => {
                columnLengths[index] = Math.max(columnLengths[index], header.text.length);
            });

            // Учитываем длину данных в ячейках
            Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
                Array.from(tr.querySelectorAll('td')).forEach((td, index) => {
                    columnLengths[index] = Math.max(columnLengths[index], td.textContent.length);
                });
            });

            // Рассчитываем относительную ширину каждой колонки
            const totalLength = columnLengths.reduce((sum, len) => sum + len, 0);
            const columnWidths = columnLengths.map(len => {
                const width = Math.max((len / totalLength) * 100, 8); // Минимум 8%
                return `${width}%`;
            });

            // Создаем строки таблицы с обновленными настройками
            const bodyRows = Array.from(table.querySelectorAll('tbody tr'))
                .map(tr => Array.from(tr.querySelectorAll('td')).map((td, index) => {
                    const headerText = table.querySelector(`thead th:nth-child(${index + 1})`).textContent.toLowerCase();
                    return {
                        text: td.textContent,
                        color: headerText === 'обробляється' ? '#198754' : 
                               headerText === 'не обробляється' ? '#dc3545' : 
                               '#000000',
                        noWrap: false
                    };
                }));

            const footerRow = Array.from(table.querySelectorAll('tfoot td')).map((td, index) => {
                const headerCell = table.querySelector(`thead th:nth-child(${index + 1})`);
                if (headerCell) {
                    const headerText = headerCell.textContent.toLowerCase();
                    return {
                        text: td.textContent,
                        style: 'tableFooter',
                        color: headerText === 'обробляється' ? '#198754' : 
                               headerText === 'не обробляється' ? '#dc3545' : 
                               '#000000',
                        noWrap: false
                    };
                }
                return {
                    text: td.textContent,
                    style: 'tableFooter'
                };
            });

            documentDefinition.content.push({
                table: {
                    headerRows: 1,
                    widths: columnWidths,
                    body: [
                        headerRow,
                        ...bodyRows,
                        footerRow
                    ]
                },
                margin: [0, 5, 0, 15],
                layout: {
                    hLineWidth: function(i, node) { return 0.5; },
                    vLineWidth: function(i, node) { return 0.5; },
                    hLineColor: function(i, node) { return '#ddd'; },
                    vLineColor: function(i, node) { return '#ddd'; },
                    paddingLeft: function(i, node) { return 4; },
                    paddingRight: function(i, node) { return 4; },
                    paddingTop: function(i, node) { return 2; },
                    paddingBottom: function(i, node) { return 2; },
                    fillColor: function(i, node) {
                        return (i === 0) ? '#f8f9fa' : null;
                    }
                }
            });
        }
    });

    // Добавляем общую площадь
    documentDefinition.content.push({
        text: `Загальна площа обміну: ${totalArea} га`,
        style: 'tenantHeader',
        margin: [0, 10, 0, 10]
    });

    // Добавляем анализ равноценности
    documentDefinition.content.push({
        text: 'АНАЛІЗ РІВНОЦІННОСТІ ОБМІНУ:',
        style: 'header',
        margin: [0, 10, 0, 10]
    });

    // Получаем результаты анализа
    Array.from(exchangeAnalysis.children).forEach(element => {
        const text = element.textContent;
        const color = element.classList.contains('text-danger') ? '#dc3545' : '#28a745';
        documentDefinition.content.push({
            text: text,
            color: color,
            margin: [0, 5]
        });
    });

    pdfMake.createPdf(documentDefinition).download(
        `пропозиція_обміну_${new Date().toISOString().slice(0,10)}.pdf`
    );
});
</script>
<script>
        // Модифицированная функция createPopupContent для правильного отображения площадей без лишних пояснений
        function createPopupContent(feature, layer) {
            let popupContent = '<div class="popup-content"><table>';
            
            // Изменяем порядок отображения свойств
            const orderedKeys = [
                "Кадастровий номер",
                "Площа розрахована", // Общая площадь участка
                "Власник",
                "Орендар частини", 
                "Орендар",
                "Дата реєстрації оренди",
                "Дата завершення",
                "Вид обмеження",
                "Статус",
                "Площа частини" // Площадь части с определенным статусом
            ];
            
            // Обрабатываем каждое поле и добавляем в таблицу
            orderedKeys.forEach(key => {
                if (feature.properties.hasOwnProperty(key)) {
                    let value = feature.properties[key] || '';
                    
                    // Форматируем числовые значения площадей с точностью до 4 знаков
                    if ((key === "Площа розрахована" || key === "Площа частини") && !isNaN(parseFloat(value))) {
                        value = parseFloat(value).toFixed(4) + " га";
                    }
                    
                    popupContent += `<tr>
                        <td class="property-name">${key}:</td>
                        <td class="property-value">${value}</td>
                    </tr>`;
                }
            });
            
            popupContent += '</table>';
            
            // Получаем кадастровый номер один раз
            const cadastralNumber = feature.properties["Кадастровий номер"];
            if (cadastralNumber) {
                // И используем его здесь
                const publicUrl = 'https://e.land.gov.ua/back/cadaster/?cad_num=' + cadastralNumber;
                popupContent += createPopupLinks(publicUrl, feature.properties["Дата оновлення"]);
            }
            
            popupContent += '</div>';
            layer.bindPopup(popupContent, {maxWidth: 300});
        }
        
        // Модифицированная функция updateSelectionInfo для отображения более детальной информации
        function updateSelectionInfo() {
            
            // Множество для отслеживания уже обработанных комбинаций
            const processedParts = new Set();
            // Кадастровые номера и общая информация
            const uniqueFeatures = new Map();
            // Информация по арендаторам
            const tenantAreas = new Map();
            // Площади по статусам
            const statusAreas = new Map();
            
            // Перебираем выбранные объекты и собираем информацию для каждого участка
            selectedFeatures.forEach(featureId => {
                Object.values(overlays).forEach(layerGroup => {
                    layerGroup.eachLayer(layer => {
                        if (L.stamp(layer) === featureId && layer.feature) {
                            const props = layer.feature.properties;
                            // Проверяем, что это действительно split-часть
                            if (props.type !== 'split') {
                                return;
                            }
                            
                            const kadNum = props["Кадастровий номер"];
                            // Используем "Площа частини" для расчетов по частям
                            const partArea = parseFloat(props["Площа частини"]) || 0;
                            // Используем "Площа розрахована" для общей площади участка
                            const totalArea = parseFloat(props["Площа розрахована"]) || 0;
                            
                            const tenant = props["Орендар частини"] || props["Орендар"] || "Без орендаря";
                            const status = props["Статус"] || "Не вказано";
                            
                            // Создаем уникальный идентификатор для каждой части участка
                            const partId = kadNum + '_' + tenant + '_' + status;

                            // Проверяем, что эта часть еще не была обработана
                            if (processedParts.has(partId)) {
                                return;
                            }
                            
                            // Проверяем корректность площади
                            if (!kadNum || isNaN(partArea) || partArea <= 0) {
                                return;
                            }

                            // Помечаем часть как обработанную
                            processedParts.add(partId);
                            
                            // Добавляем или обновляем информацию для кадастрового номера
                            if (!uniqueFeatures.has(kadNum)) {
                                uniqueFeatures.set(kadNum, {
                                    totalArea: totalArea, // Общая площадь участка
                                    partAreas: {}, // Площади по частям и статусам
                                    tenant: tenant // Основной арендатор
                                });
                            }
                            
                            const featInfo = uniqueFeatures.get(kadNum);
                            // Добавляем площадь части в соответствующий статус
                            featInfo.partAreas[status] = (featInfo.partAreas[status] || 0) + partArea;
                            
                            // Обновляем площадь арендатора (используем общую площадь участка)
                            if (!tenantAreas.has(tenant)) {
                                tenantAreas.set(tenant, {
                                    totalArea: 0, // Общая площадь всех участков арендатора
                                    partsArea: 0 // Сумма площадей частей
                                });
                            }
                            const tenantInfo = tenantAreas.get(tenant);
                            // Учитываем каждый уникальный кадастровый номер только один раз для общей площади
                            if (!featInfo.tenantCounted) {
                                tenantInfo.totalArea += totalArea;
                                featInfo.tenantCounted = true;
                            }
                            // Всегда добавляем площадь части
                            tenantInfo.partsArea += partArea;
                            
                            // Обновляем площадь статуса
                            const currentStatusArea = statusAreas.get(status) || 0;
                            statusAreas.set(status, currentStatusArea + partArea);
                            
                        }
                    });
                });
            });

            // Создаем сводки для отображения
            
            // Подсчитываем общую площадь как сумму общих площадей участков
            const totalSelectedArea = Array.from(uniqueFeatures.values()).reduce((sum, info) => sum + info.totalArea, 0);
            const totalPartsArea = Array.from(statusAreas.values()).reduce((sum, area) => sum + area, 0);
            
            // Обновляем интерфейс, если есть выбранные участки
            const infoElement = document.getElementById('selectionInfo');
            const selectionTools = document.getElementById('selectionTools');

            if (uniqueFeatures.size > 0) {
                if (!infoElement) {
                    // Создаем элемент информации, если его нет
                    const info = L.control({position: 'bottomleft'});
                    info.onAdd = function() {
                        const div = L.DomUtil.create('div', 'selection-info');
                        div.id = 'selectionInfo';
                        div.style.background = 'white';
                        div.style.color = 'black';
                        div.style.padding = '6px';
                        div.style.border = '2px solid #666';
                        div.style.borderRadius = '4px';
                        div.style.maxWidth = '300px';
                        return div;
                    };
                    info.addTo(map);
                }

                // Формируем информацию по арендаторам (показываем общую площадь)
                let tenantsInfo = '';
                tenantAreas.forEach((data, tenant) => {
                    const color = tenant === "Без орендаря" ? "#ffffff" : getColor(tenant);
                    tenantsInfo += `
                        <div style="display: flex; align-items: center; margin-top: 3px;">
                            <span style="
                                display: inline-block;
                                width: 12px;
                                height: 12px;
                                margin-right: 5px;
                                background-color: ${color};
                                border: 1px solid #666;
                                border-radius: 2px;
                            "></span>
                            <span>${tenant}: ${data.totalArea.toFixed(4)} га</span>
                        </div>`;
                });
                
                // Формируем информацию по статусам (показываем сумму площадей частей)
                let statusInfo = '';
                statusAreas.forEach((area, status) => {
                    const statusText = status.toLowerCase();
                    const color = statusText === 'обробляється' ? '#198754' : 
                                 statusText === 'не обробляється' ? '#dc3545' : 
                                 '#666666';
                    statusInfo += `
                        <div style="display: flex; align-items: center; margin-top: 3px;">
                            <span style="
                                display: inline-block;
                                width: 12px;
                                height: 12px;
                                margin-right: 5px;
                                background-color: ${color};
                                border: 1px solid #666;
                                border-radius: 2px;
                            "></span>
                            <span>${status}: ${area.toFixed(4)} га</span>
                        </div>`;
                });

                // Обновляем HTML содержимое
                document.getElementById('selectionInfo').innerHTML = `
                    <div style="max-height: 300px; overflow-y: auto;">
                        <div>
                            <b>Виділено ділянок:</b> ${uniqueFeatures.size}<br>
                            <div style="margin-top: 3px;">
                                <b>Загальна площа:</b> ${totalSelectedArea.toFixed(4)} га
                            </div>
                        </div>
                        <hr style="margin: 4px 0">
                        <div>
                            ${tenantsInfo}
                        </div>
                        <hr style="margin: 4px 0">
                        <div>
                            <strong>Розподіл за статусами:</strong>
                            ${statusInfo}
                        </div>
                        <div style="margin-top: 3px; font-size: 0.9em; color: #666; text-align: right;">
                            Площа частин: ${totalPartsArea.toFixed(4)} га
                        </div>
                    </div>`;

                // Показываем инструменты выделения
                if (selectionTools) {
                    selectionTools.style.display = 'block';
                }
            } else {
                // Если нет выделенных участков, удаляем информационный блок
                if (infoElement) {
                    infoElement.remove();
                }
                // Скрываем инструменты выделения
                if (selectionTools) {
                    selectionTools.style.display = 'none';
                }
            }
            
        }
        
        // ...existing code...
        
        // Обновления для функции exportSelectedToExcel для включения общей площади
        function exportSelectedToExcel() {
            const rows = [
                // Обновляем заголовки для включения обоих видов площадей
                [
                    "Кадастровий номер", 
                    "Площа розрахована", 
                    "Площа частини", 
                    "Власник", 
                    "Орендар частини", 
                    "Орендар", 
                    "Статус"
                ]
            ];
            
            const uniqueFeatures = new Map();
            selectedFeatures.forEach(featureId => {
                Object.values(overlays).forEach(layerGroup => {
                    layerGroup.eachLayer(layer => {
                        if (L.stamp(layer) === featureId && layer.feature) {
                            const props = layer.feature.properties;
                            
                            // Используем кадастровый номер + статус как уникальный идентификатор
                            // чтобы не потерять разные части одного участка
                            const kadNum = props["Кадастровий номер"];
                            const status = props["Статус"] || "";
                            const key = kadNum + "_" + status;
                            
                            if (kadNum && !uniqueFeatures.has(key)) {
                                uniqueFeatures.set(key, [
                                    kadNum,
                                    props["Площа розрахована"] || "",
                                    props["Площа частини"] || "",
                                    props["Власник"] || "",
                                    props["Орендар частини"] || "",
                                    props["Орендар"] || "",
                                    status
                                ]);
                            }
                        }
                    });
                });
            });
            
            uniqueFeatures.forEach(row => rows.push(row));
            
            if (rows.length < 2) {
                alert("Немає даних для експорту");
                return;
            }
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);
            XLSX.utils.book_append_sheet(wb, ws, "Selected");
            XLSX.writeFile(wb, "виділені ділянки.xlsx");
        }
        
        // ...existing code...
</script>
<script>
        // ...existing code...

        // Модифицируем функцию для сбора данных карты, чтобы она собирала с текущей карты
        function collectMapData() {
            const data = [];
            
            // Собираем данные со всех слоев, которые отображаются на карте
            Object.values(overlays).forEach(layerGroup => {
                if (!layerGroup || typeof layerGroup.eachLayer !== 'function') return;
                
                layerGroup.eachLayer(layer => {
                    // Проверяем, что у слоя есть свойства
                    if (layer.feature && layer.feature.properties) {
                        // Проверяем, что это split-часть
                        if (layer.feature.properties.type === 'split') {
                            data.push(layer.feature.properties);
                        }
                    }
                });
            });
            
            return data;
        }

        // Исправленная функция exportToExcel
        function exportToExcel(data, filename) {
            // Если данных нет, выводим ошибку
            if (data.length === 0) {
                alert('Немає даних для експорту. Перевірте, що на карті є відображені об\'єкти.');
                return;
            }
            
            // Сортируем по кадастровому номеру
            data.sort((a, b) => {
                const kadNumA = a["Кадастровий номер"] || "";
                const kadNumB = b["Кадастровий номер"] || "";
                return kadNumA.localeCompare(kadNumB);
            });
            
            // Приоритетные поля для отображения в начале
            const priorityKeys = [
                "Кадастровий номер",
                "Площа розрахована",
                "Площа частини", 
                "Власник",
                "Орендар частини",
                "Орендар",
                "Дата реєстрації оренди",
                "Дата завершення",
                "Назва поля",
                "Статус"
            ];
            
            // Собираем все уникальные ключи из данных
            const allKeys = new Set();
            data.forEach(item => {
                Object.keys(item).forEach(key => {
                    if (key !== 'type') { // Исключаем служебное поле
                        allKeys.add(key);
                    }
                });
            });
            
            // Формируем заголовки с приоритезацией
            const headers = [];
            
            // Сначала добавляем приоритетные поля
            priorityKeys.forEach(key => {
                if (allKeys.has(key)) {
                    headers.push(key);
                    allKeys.delete(key);
                }
            });
            
            // Затем добавляем остальные поля по алфавиту
            Array.from(allKeys).sort().forEach(key => {
                headers.push(key);
            });
            
            // Создаем строки для Excel
            const rows = [headers];
            data.forEach(item => {
                const row = headers.map(header => item[header] || "");
                rows.push(row);
            });
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);
            XLSX.utils.book_append_sheet(wb, ws, "Ділянки");
            XLSX.writeFile(wb, filename + ".xlsx");
        }
        
        // ...existing code...

    // Единая функция экспорта
    function exportToExcel() {
        
        // Получаем имя файла
        const selectedFile = document.getElementById('fileSelect').value;
        const filename = selectedFile.replace('.geojson', '') || 'експорт_даних';
        
        // Собираем данные только с видимых слоев
        const data = [];
        const processedIds = new Set(); // Для избежания дубликатов
        
        Object.values(overlays).forEach(layerGroup => {
            if (!layerGroup || typeof layerGroup.eachLayer !== 'function') return;
            
            // Проверяем видимость слоя
            if (map.hasLayer(layerGroup)) {
                layerGroup.eachLayer(layer => {
                    if (layer.feature?.properties?.type === 'split') {
                        const props = layer.feature.properties;
                        const id = `${props["Кадастровий номер"]}_${props["Орендар частини"] || props["Орендар"] || ""}_${props["Статус"] || ""}`;
                        
                        if (!processedIds.has(id)) {
                            processedIds.add(id);
                            data.push(props);
                        }
                    }
                });
            }
        });

        
        if (data.length === 0) {
            alert('Немає даних для експорту. Перевірте, що на карті є відображені об\'єкти.');
            return;
        }

        try {
            // Сортировка и экспорт
            data.sort((a, b) => (a["Кадастровий номер"] || "").localeCompare(b["Кадастровий номер"] || ""));
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([
                // Заголовки
                ["Кадастровий номер", "Площа розрахована", "Площа частини", "Власник", 
                 "Орендар частини", "Орендар", "Дата реєстрації оренди", "Дата завершення", 
                 "Назва поля", "Статус"],
                // Данные
                ...data.map(item => [
                    item["Кадастровий номер"] || "",
                    item["Площа розрахована"] || "",
                    item["Площа частини"] || "",
                    item["Власник"] || "",
                    item["Орендар частини"] || "",
                    item["Орендар"] || "",
                    item["Дата реєстрації оренди"] || "",
                    item["Дата завершення"] || "",
                    item["Назва поля"] || "",
                    item["Статус"] || ""
                ])
            ]);
            
            XLSX.utils.book_append_sheet(wb, ws, "Ділянки");
            XLSX.writeFile(wb, `${filename}.xlsx`);
            
            
        } catch (error) {
            console.error('Ошибка при экспорте:', error);
            alert('Помилка при експорті: ' + error.message);
        }
    }

    // ...existing code...

    // УДАЛИТЬ ВСЕ СТАРЫЕ ОБРАБОТЧИКИ И ФУНКЦИИ ЭКСПОРТА
    // function exportToExcel(data, filename) { ... } - УДАЛИТЬ
    // function collectMapData() { ... } - УДАЛИТЬ

    // Единый обработчик для кнопки экспорта
    document.addEventListener('DOMContentLoaded', function() {
        const exportBtn = document.getElementById('exportButton');
        if (exportBtn) {
            // Удаляем все существующие обработчики
            const newBtn = exportBtn.cloneNode(true);
            exportBtn.parentNode.replaceChild(newBtn, exportBtn);
            
            // Добавляем только один обработчик
            newBtn.addEventListener('click', function() {
                const offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('mainMenu'));
                if (offcanvas) {
                    offcanvas.hide();
                    setTimeout(exportToExcel, 300);
                } else {
                    exportToExcel();
                }
            });
        }
    });

    // ...existing code...
</script>

<script>
        // ...existing code...

function exportToExcel() {
    
    
    const selectedFile = document.getElementById('fileSelect').value;
    const filename = selectedFile.replace('.geojson', '') || 'експорт_даних';
    
    const data = [];
    const processedIds = new Set();
    
    Object.values(overlays).forEach(layerGroup => {
        if (!layerGroup || typeof layerGroup.eachLayer !== 'function') return;
        
        if (map.hasLayer(layerGroup)) {
            layerGroup.eachLayer(layer => {
                if (layer.feature?.properties?.type === 'split') {
                    const props = layer.feature.properties;
                    const id = `${props["Кадастровий номер"]}_${props["Орендар частини"] || props["Орендар"] || ""}_${props["Статус"] || ""}`;
                    
                    if (!processedIds.has(id)) {
                        processedIds.add(id);
                        data.push(props);
                    }
                }
            });
        }
    });

    if (data.length === 0) {
        alert('Немає даних для експорту. Перевірте, що на карті є відображені об\'єкти.');
        return;
    }

    try {
        // Сортировка данных
        data.sort((a, b) => (a["Кадастровий номер"] || "").localeCompare(b["Кадастровий номер"] || ""));
        
        // Заголовки колонок
        const headers = [
            "Кадастровий номер", 
            "Площа розрахована", 
            "Площа частини", 
            "Власник", 
            "Орендар частини", 
            "Орендар", 
            "Дата реєстрації оренди", 
            "Дата завершення", 
            "Назва поля", 
            "Статус"
        ];
        
        // Создаем книгу и лист
        const wb = XLSX.utils.book_new();
        
        // Подготавливаем данные для листа
        const wsData = [
            headers,
            ...data.map(item => headers.map(header => item[header] || ""))
        ];
        
        // Создаем лист
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        
        // Получаем максимальную длину для каждой колонки
        const colWidths = headers.map((_, colIndex) => {
            return Math.max(
                // Длина заголовка
                headers[colIndex].length,
                // Максимальная длина данных в колонке
                ...wsData.slice(1).map(row => 
                    String(row[colIndex] || "").length
                )
            );
        });
        
        // Устанавливаем ширину колонок
        ws['!cols'] = colWidths.map(width => ({
            // Конвертируем символы в условные единицы Excel 
            // (примерно 1.2 единицы на символ)
            width: Math.min(width * 1.2, 50) // Ограничиваем максимальную ширину
        }));
        
        // Добавляем стили для заголовков
        const headerRange = XLSX.utils.decode_range(ws['!ref']);
        for (let C = headerRange.s.c; C <= headerRange.e.c; ++C) {
            const headerCell = XLSX.utils.encode_cell({ r: 0, c: C });
            if (!ws[headerCell]) continue;
            
            ws[headerCell].s = {
                font: { bold: true },
                fill: { fgColor: { rgb: "CCCCCC" } },
                alignment: { horizontal: "center" }
            };
        }
        
        // Добавляем лист в книгу и сохраняем
        XLSX.utils.book_append_sheet(wb, ws, "Ділянки");
        XLSX.writeFile(wb, `${filename}.xlsx`);
        
        
    } catch (error) {
        console.error('Ошибка при экспорте:', error);
        alert('Помилка при експорті: ' + error.message);
    }
}

// ...existing code...
</script>

<script>
    map.addControl(drawControl);

    // Додаємо обробник події створення полігону
    map.on(L.Draw.Event.CREATED, function (e) {
        var layer = e.layer;
        
        // Рахуємо площу в гектарах
        var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
        var areaInHectares = (area / 10000).toFixed(4);
        
        // Додаємо попап з площею
        layer.bindPopup('Площа: ' + areaInHectares + ' га');
        
        // Додаємо полігон до шару для редагування
        editableLayers.addLayer(layer);
    });

    // Оновлюємо попап з площею при редагуванні
    map.on(L.Draw.Event.EDITED, function (e) {
        e.layers.eachLayer(function (layer) {
            if (layer instanceof L.Polygon) {
                var area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                var areaInHectares = (area / 10000).toFixed(4);
                layer.setPopupContent('Площа: ' + areaInHectares + ' га');
            }
        });
    });
</script>

</body>
</html>
